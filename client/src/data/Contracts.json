[
	{
		"SourceCode": "/*\n\n- Bytecode Verification performed was compared on second iteration -\n\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nBasic, standardized Token contract with no \"premine\". Defines the functions to\ncheck token balances, send tokens, send tokens on behalf of a 3rd party and the\ncorresponding approval process. Tokens need to be created by a derived\ncontract (e.g. TokenCreation.sol).\n\nThank you ConsenSys, this contract originated from:\nhttps://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Standard_Token.sol\nWhich is itself based on the Ethereum standardized contract APIs:\nhttps://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs\n*/\n\n/// @title Standard Token Contract.\n\ncontract TokenInterface {\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    /// Total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`\n    /// @param _from The address of the origin of the transfer\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    /// its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _amount) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    /// to spend\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n    );\n}\n\n\ncontract Token is TokenInterface {\n    // Protects users by preventing the execution of method calls that\n    // inadvertently also transferred ether\n    modifier noEther() {if (msg.value > 0) throw; _}\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _amount) noEther returns (bool success) {\n        if (balances[msg.sender] >= _amount && _amount > 0) {\n            balances[msg.sender] -= _amount;\n            balances[_to] += _amount;\n            Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) noEther returns (bool success) {\n\n        if (balances[_from] >= _amount\n            && allowed[_from][msg.sender] >= _amount\n            && _amount > 0) {\n\n            balances[_to] += _amount;\n            balances[_from] -= _amount;\n            allowed[_from][msg.sender] -= _amount;\n            Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function approve(address _spender, uint256 _amount) returns (bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\n\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nBasic account, used by the DAO contract to separately manage both the rewards \nand the extraBalance accounts. \n*/\n\ncontract ManagedAccountInterface {\n    // The only address with permission to withdraw from this account\n    address public owner;\n    // If true, only the owner of the account can receive ether from it\n    bool public payOwnerOnly;\n    // The sum of ether (in wei) which has been sent to this contract\n    uint public accumulatedInput;\n\n    /// @notice Sends `_amount` of wei to _recipient\n    /// @param _amount The amount of wei to send to `_recipient`\n    /// @param _recipient The address to receive `_amount` of wei\n    /// @return True if the send completed\n    function payOut(address _recipient, uint _amount) returns (bool);\n\n    event PayOut(address indexed _recipient, uint _amount);\n}\n\n\ncontract ManagedAccount is ManagedAccountInterface{\n\n    // The constructor sets the owner of the account\n    function ManagedAccount(address _owner, bool _payOwnerOnly) {\n        owner = _owner;\n        payOwnerOnly = _payOwnerOnly;\n    }\n\n    // When the contract receives a transaction without data this is called. \n    // It counts the amount of ether it receives and stores it in \n    // accumulatedInput.\n    function() {\n        accumulatedInput += msg.value;\n    }\n\n    function payOut(address _recipient, uint _amount) returns (bool) {\n        if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))\n            throw;\n        if (_recipient.call.value(_amount)()) {\n            PayOut(_recipient, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\n * Token Creation contract, used by the DAO to create its tokens and initialize\n * its ether. Feel free to modify the divisor method to implement different\n * Token Creation parameters\n*/\n\n\ncontract TokenCreationInterface {\n\n    // End of token creation, in Unix time\n    uint public closingTime;\n    // Minimum fueling goal of the token creation, denominated in tokens to\n    // be created\n    uint public minTokensToCreate;\n    // True if the DAO reached its minimum fueling goal, false otherwise\n    bool public isFueled;\n    // For DAO splits - if privateCreation is 0, then it is a public token\n    // creation, otherwise only the address stored in privateCreation is\n    // allowed to create tokens\n    address public privateCreation;\n    // hold extra ether which has been sent after the DAO token\n    // creation rate has increased\n    ManagedAccount public extraBalance;\n    // tracks the amount of wei given from each contributor (used for refund)\n    mapping (address => uint256) weiGiven;\n\n    /// @dev Constructor setting the minimum fueling goal and the\n    /// end of the Token Creation\n    /// @param _minTokensToCreate Minimum fueling goal in number of\n    ///        Tokens to be created\n    /// @param _closingTime Date (in Unix time) of the end of the Token Creation\n    /// @param _privateCreation Zero means that the creation is public.  A\n    /// non-zero address represents the only address that can create Tokens\n    /// (the address can also create Tokens on behalf of other accounts)\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function TokenCreation(\n        //  uint _minTokensTocreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `_tokenHolder` as the initial owner of the Token\n    /// @param _tokenHolder The address of the Tokens's recipient\n    /// @return Whether the token creation was successful\n    function createTokenProxy(address _tokenHolder) returns (bool success);\n\n    /// @notice Refund `msg.sender` in the case the Token Creation did\n    /// not reach its minimum fueling goal\n    function refund();\n\n    /// @return The divisor used to calculate the token creation rate during\n    /// the creation phase\n    function divisor() constant returns (uint divisor);\n\n    event FuelingToDate(uint value);\n    event CreatedToken(address indexed to, uint amount);\n    event Refund(address indexed to, uint value);\n}\n\n\ncontract TokenCreation is TokenCreationInterface, Token {\n    function TokenCreation(\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation) {\n\n        closingTime = _closingTime;\n        minTokensToCreate = _minTokensToCreate;\n        privateCreation = _privateCreation;\n        extraBalance = new ManagedAccount(address(this), true);\n    }\n\n    function createTokenProxy(address _tokenHolder) returns (bool success) {\n        if (now < closingTime && msg.value > 0\n            && (privateCreation == 0 || privateCreation == msg.sender)) {\n\n            uint token = (msg.value * 20) / divisor();\n            extraBalance.call.value(msg.value - token)();\n            balances[_tokenHolder] += token;\n            totalSupply += token;\n            weiGiven[_tokenHolder] += msg.value;\n            CreatedToken(_tokenHolder, token);\n            if (totalSupply >= minTokensToCreate && !isFueled) {\n                isFueled = true;\n                FuelingToDate(totalSupply);\n            }\n            return true;\n        }\n        throw;\n    }\n\n    function refund() noEther {\n        if (now > closingTime && !isFueled) {\n            // Get extraBalance - will only succeed when called for the first time\n            if (extraBalance.balance >= extraBalance.accumulatedInput())\n                extraBalance.payOut(address(this), extraBalance.accumulatedInput());\n\n            // Execute refund\n            if (msg.sender.call.value(weiGiven[msg.sender])()) {\n                Refund(msg.sender, weiGiven[msg.sender]);\n                totalSupply -= balances[msg.sender];\n                balances[msg.sender] = 0;\n                weiGiven[msg.sender] = 0;\n            }\n        }\n    }\n\n    function divisor() constant returns (uint divisor) {\n        // The number of (base unit) tokens per wei is calculated\n        // as `msg.value` * 20 / `divisor`\n        // The fueling period starts with a 1:1 ratio\n        if (closingTime - 2 weeks > now) {\n            return 20;\n        // Followed by 10 days with a daily creation rate increase of 5%\n        } else if (closingTime - 4 days > now) {\n            return (20 + (now - (closingTime - 2 weeks)) / (1 days));\n        // The last 4 days there is a constant creation rate ratio of 1:1.5\n        } else {\n            return 30;\n        }\n    }\n}\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nStandard smart contract for a Decentralized Autonomous Organization (DAO)\nto automate organizational governance and decision-making.\n*/\n\n\ncontract DAOInterface {\n\n    // The amount of days for which people who try to participate in the\n    // creation by calling the fallback function will still get their ether back\n    uint constant creationGracePeriod = 40 days;\n    // The minimum debate period that a generic proposal can have\n    uint constant minProposalDebatePeriod = 2 weeks;\n    // The minimum debate period that a split proposal can have\n    uint constant minSplitDebatePeriod = 1 weeks;\n    // Period of days inside which it's possible to execute a DAO split\n    uint constant splitExecutionPeriod = 27 days;\n    // Period of time after which the minimum Quorum is halved\n    uint constant quorumHalvingPeriod = 25 weeks;\n    // Period after which a proposal is closed\n    // (used in the case `executeProposal` fails because it throws)\n    uint constant executeProposalPeriod = 10 days;\n    // Denotes the maximum proposal deposit that can be given. It is given as\n    // a fraction of total Ether spent plus balance of the DAO\n    uint constant maxDepositDivisor = 100;\n\n    // Proposals to spend the DAO's ether or to choose a new Curator\n    Proposal[] public proposals;\n    // The quorum needed for each proposal is partially calculated by\n    // totalSupply / minQuorumDivisor\n    uint public minQuorumDivisor;\n    // The unix time of the last time quorum was reached on a proposal\n    uint  public lastTimeMinQuorumMet;\n\n    // Address of the curator\n    address public curator;\n    // The whitelist: List of addresses the DAO is allowed to send ether to\n    mapping (address => bool) public allowedRecipients;\n\n    // Tracks the addresses that own Reward Tokens. Those addresses can only be\n    // DAOs that have split from the original DAO. Conceptually, Reward Tokens\n    // represent the proportion of the rewards that the DAO has the right to\n    // receive. These Reward Tokens are generated when the DAO spends ether.\n    mapping (address => uint) public rewardToken;\n    // Total supply of rewardToken\n    uint public totalRewardToken;\n\n    // The account used to manage the rewards which are to be distributed to the\n    // DAO Token Holders of this DAO\n    ManagedAccount public rewardAccount;\n\n    // The account used to manage the rewards which are to be distributed to\n    // any DAO that holds Reward Tokens\n    ManagedAccount public DAOrewardAccount;\n\n    // Amount of rewards (in wei) already paid out to a certain DAO\n    mapping (address => uint) public DAOpaidOut;\n\n    // Amount of rewards (in wei) already paid out to a certain address\n    mapping (address => uint) public paidOut;\n    // Map of addresses blocked during a vote (not allowed to transfer DAO\n    // tokens). The address points to the proposal ID.\n    mapping (address => uint) public blocked;\n\n    // The minimum deposit (in wei) required to submit any proposal that is not\n    // requesting a new Curator (no deposit is required for splits)\n    uint public proposalDeposit;\n\n    // the accumulated sum of all current proposal deposits\n    uint sumOfProposalDeposits;\n\n    // Contract that is able to create a new DAO (with the same code as\n    // this one), used for splits\n    DAO_Creator public daoCreator;\n\n    // A proposal with `newCurator == false` represents a transaction\n    // to be issued by this DAO\n    // A proposal with `newCurator == true` represents a DAO split\n    struct Proposal {\n        // The address where the `amount` will go to if the proposal is accepted\n        // or if `newCurator` is true, the proposed Curator of\n        // the new DAO).\n        address recipient;\n        // The amount to transfer to `recipient` if the proposal is accepted.\n        uint amount;\n        // A plain text description of the proposal\n        string description;\n        // A unix timestamp, denoting the end of the voting period\n        uint votingDeadline;\n        // True if the proposal's votes have yet to be counted, otherwise False\n        bool open;\n        // True if quorum has been reached, the votes have been counted, and\n        // the majority said yes\n        bool proposalPassed;\n        // A hash to check validity of a proposal\n        bytes32 proposalHash;\n        // Deposit in wei the creator added when submitting their proposal. It\n        // is taken from the msg.value of a newProposal call.\n        uint proposalDeposit;\n        // True if this proposal is to assign a new Curator\n        bool newCurator;\n        // Data needed for splitting the DAO\n        SplitData[] splitData;\n        // Number of Tokens in favor of the proposal\n        uint yea;\n        // Number of Tokens opposed to the proposal\n        uint nay;\n        // Simple mapping to check if a shareholder has voted for it\n        mapping (address => bool) votedYes;\n        // Simple mapping to check if a shareholder has voted against it\n        mapping (address => bool) votedNo;\n        // Address of the shareholder who created the proposal\n        address creator;\n    }\n\n    // Used only in the case of a newCurator proposal.\n    struct SplitData {\n        // The balance of the current DAO minus the deposit at the time of split\n        uint splitBalance;\n        // The total amount of DAO Tokens in existence at the time of split.\n        uint totalSupply;\n        // Amount of Reward Tokens owned by the DAO at the time of split.\n        uint rewardToken;\n        // The new DAO contract created at the time of split.\n        DAO newDAO;\n    }\n\n    // Used to restrict access to certain functions to only DAO Token Holders\n    modifier onlyTokenholders {}\n\n    /// @dev Constructor setting the Curator and the address\n    /// for the contract able to create another DAO as well as the parameters\n    /// for the DAO Token Creation\n    /// @param _curator The Curator\n    /// @param _daoCreator The contract able to (re)create this DAO\n    /// @param _proposalDeposit The deposit to be paid for a regular proposal\n    /// @param _minTokensToCreate Minimum required wei-equivalent tokens\n    ///        to be created for a successful DAO Token Creation\n    /// @param _closingTime Date (in Unix time) of the end of the DAO Token Creation\n    /// @param _privateCreation If zero the DAO Token Creation is open to public, a\n    /// non-zero address means that the DAO Token Creation is only for the address\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function DAO(\n        //  address _curator,\n        //  DAO_Creator _daoCreator,\n        //  uint _proposalDeposit,\n        //  uint _minTokensToCreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `msg.sender` as the beneficiary\n    /// @return Whether the token creation was successful\n    function () returns (bool success);\n\n\n    /// @dev This function is used to send ether back\n    /// to the DAO, it can also be used to receive payments that should not be\n    /// counted as rewards (donations, grants, etc.)\n    /// @return Whether the DAO received the ether successfully\n    function receiveEther() returns(bool);\n\n    /// @notice `msg.sender` creates a proposal to send `_amount` Wei to\n    /// `_recipient` with the transaction data `_transactionData`. If\n    /// `_newCurator` is true, then this is a proposal that splits the\n    /// DAO and sets `_recipient` as the new DAO's Curator.\n    /// @param _recipient Address of the recipient of the proposed transaction\n    /// @param _amount Amount of wei to be sent with the proposed transaction\n    /// @param _description String describing the proposal\n    /// @param _transactionData Data of the proposed transaction\n    /// @param _debatingPeriod Time used for debating a proposal, at least 2\n    /// weeks for a regular proposal, 10 days for new Curator proposal\n    /// @param _newCurator Bool defining whether this proposal is about\n    /// a new Curator or not\n    /// @return The proposal ID. Needed for voting on the proposal\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID);\n\n    /// @notice Check that the proposal with the ID `_proposalID` matches the\n    /// transaction which sends `_amount` with data `_transactionData`\n    /// to `_recipient`\n    /// @param _proposalID The proposal ID\n    /// @param _recipient The recipient of the proposed transaction\n    /// @param _amount The amount of wei to be sent in the proposed transaction\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposal ID matches the transaction data or not\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) constant returns (bool _codeChecksOut);\n\n    /// @notice Vote on proposal `_proposalID` with `_supportsProposal`\n    /// @param _proposalID The proposal ID\n    /// @param _supportsProposal Yes/No - support of the proposal\n    /// @return The vote ID.\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders returns (uint _voteID);\n\n    /// @notice Checks whether proposal `_proposalID` with transaction data\n    /// `_transactionData` has been voted for or rejected, and executes the\n    /// transaction in the case it has been voted for.\n    /// @param _proposalID The proposal ID\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposed transaction has been executed or not\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) returns (bool _success);\n\n    /// @notice ATTENTION! I confirm to move my remaining ether to a new DAO\n    /// with `_newCurator` as the new Curator, as has been\n    /// proposed in proposal `_proposalID`. This will burn my tokens. This can\n    /// not be undone and will split the DAO into two DAO's, with two\n    /// different underlying tokens.\n    /// @param _proposalID The proposal ID\n    /// @param _newCurator The new Curator of the new DAO\n    /// @dev This function, when called for the first time for this proposal,\n    /// will create a new DAO and send the sender's portion of the remaining\n    /// ether and Reward Tokens to the new DAO. It will also burn the DAO Tokens\n    /// of the sender.\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) returns (bool _success);\n\n    /// @dev can only be called by the DAO itself through a proposal\n    /// updates the contract of the DAO by sending all ether and rewardTokens\n    /// to the new DAO. The new DAO needs to be approved by the Curator\n    /// @param _newContract the address of the new contract\n    function newContract(address _newContract);\n\n\n    /// @notice Add a new possible recipient `_recipient` to the whitelist so\n    /// that the DAO can send transactions to them (using proposals)\n    /// @param _recipient New recipient address\n    /// @dev Can only be called by the current Curator\n    /// @return Whether successful or not\n    function changeAllowedRecipients(address _recipient, bool _allowed) external returns (bool _success);\n\n\n    /// @notice Change the minimum deposit required to submit a proposal\n    /// @param _proposalDeposit The new proposal deposit\n    /// @dev Can only be called by this DAO (through proposals with the\n    /// recipient being this DAO itself)\n    function changeProposalDeposit(uint _proposalDeposit) external;\n\n    /// @notice Move rewards from the DAORewards managed account\n    /// @param _toMembers If true rewards are moved to the actual reward account\n    ///                   for the DAO. If not then it's moved to the DAO itself\n    /// @return Whether the call was successful\n    function retrieveDAOReward(bool _toMembers) external returns (bool _success);\n\n    /// @notice Get my portion of the reward that was sent to `rewardAccount`\n    /// @return Whether the call was successful\n    function getMyReward() returns(bool _success);\n\n    /// @notice Withdraw `_account`'s portion of the reward from `rewardAccount`\n    /// to `_account`'s balance\n    /// @return Whether the call was successful\n    function withdrawRewardFor(address _account) internal returns (bool _success);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`. Prior to this\n    /// getMyReward() is called.\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferWithoutReward(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`. Prior to this getMyReward() is called.\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) returns (bool success);\n\n    /// @notice Doubles the 'minQuorumDivisor' in the case quorum has not been\n    /// achieved in 52 weeks\n    /// @return Whether the change was successful or not\n    function halveMinQuorum() returns (bool _success);\n\n    /// @return total number of proposals ever created\n    function numberOfProposals() constant returns (uint _numberOfProposals);\n\n    /// @param _proposalID Id of the new curator proposal\n    /// @return Address of the new DAO\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO);\n\n    /// @param _account The address of the account which is checked.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function isBlocked(address _account) internal returns (bool);\n\n    /// @notice If the caller is blocked by a proposal whose voting deadline\n    /// has exprired then unblock him.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function unblockMe() returns (bool);\n\n    event ProposalAdded(\n        uint indexed proposalID,\n        address recipient,\n        uint amount,\n        bool newCurator,\n        string description\n    );\n    event Voted(uint indexed proposalID, bool position, address indexed voter);\n    event ProposalTallied(uint indexed proposalID, bool result, uint quorum);\n    event NewCurator(address indexed _newCurator);\n    event AllowedRecipientChanged(address indexed _recipient, bool _allowed);\n}\n\n// The DAO contract itself\ncontract DAO is DAOInterface, Token, TokenCreation {\n\n    // Modifier that allows only shareholders to vote and create new proposals\n    modifier onlyTokenholders {\n        if (balanceOf(msg.sender) == 0) throw;\n            _\n    }\n\n    function DAO(\n        address _curator,\n        DAO_Creator _daoCreator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation\n    ) TokenCreation(_minTokensToCreate, _closingTime, _privateCreation) {\n\n        curator = _curator;\n        daoCreator = _daoCreator;\n        proposalDeposit = _proposalDeposit;\n        rewardAccount = new ManagedAccount(address(this), false);\n        DAOrewardAccount = new ManagedAccount(address(this), false);\n        if (address(rewardAccount) == 0)\n            throw;\n        if (address(DAOrewardAccount) == 0)\n            throw;\n        lastTimeMinQuorumMet = now;\n        minQuorumDivisor = 5; // sets the minimal quorum to 20%\n        proposals.length = 1; // avoids a proposal with ID 0 because it is used\n\n        allowedRecipients[address(this)] = true;\n        allowedRecipients[curator] = true;\n    }\n\n    function () returns (bool success) {\n        if (now < closingTime + creationGracePeriod && msg.sender != address(extraBalance))\n            return createTokenProxy(msg.sender);\n        else\n            return receiveEther();\n    }\n\n\n    function receiveEther() returns (bool) {\n        return true;\n    }\n\n\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID) {\n\n        // Sanity check\n        if (_newCurator && (\n            _amount != 0\n            || _transactionData.length != 0\n            || _recipient == curator\n            || msg.value > 0\n            || _debatingPeriod < minSplitDebatePeriod)) {\n            throw;\n        } else if (\n            !_newCurator\n            && (!isRecipientAllowed(_recipient) || (_debatingPeriod <  minProposalDebatePeriod))\n        ) {\n            throw;\n        }\n\n        if (_debatingPeriod > 8 weeks)\n            throw;\n\n        if (!isFueled\n            || now < closingTime\n            || (msg.value < proposalDeposit && !_newCurator)) {\n\n            throw;\n        }\n\n        if (now + _debatingPeriod < now) // prevents overflow\n            throw;\n\n        // to prevent a 51% attacker to convert the ether into deposit\n        if (msg.sender == address(this))\n            throw;\n\n        _proposalID = proposals.length++;\n        Proposal p = proposals[_proposalID];\n        p.recipient = _recipient;\n        p.amount = _amount;\n        p.description = _description;\n        p.proposalHash = sha3(_recipient, _amount, _transactionData);\n        p.votingDeadline = now + _debatingPeriod;\n        p.open = true;\n        //p.proposalPassed = False; // that's default\n        p.newCurator = _newCurator;\n        if (_newCurator)\n            p.splitData.length++;\n        p.creator = msg.sender;\n        p.proposalDeposit = msg.value;\n\n        sumOfProposalDeposits += msg.value;\n\n        ProposalAdded(\n            _proposalID,\n            _recipient,\n            _amount,\n            _newCurator,\n            _description\n        );\n    }\n\n\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) noEther constant returns (bool _codeChecksOut) {\n        Proposal p = proposals[_proposalID];\n        return p.proposalHash == sha3(_recipient, _amount, _transactionData);\n    }\n\n\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders noEther returns (uint _voteID) {\n\n        Proposal p = proposals[_proposalID];\n        if (p.votedYes[msg.sender]\n            || p.votedNo[msg.sender]\n            || now >= p.votingDeadline) {\n\n            throw;\n        }\n\n        if (_supportsProposal) {\n            p.yea += balances[msg.sender];\n            p.votedYes[msg.sender] = true;\n        } else {\n            p.nay += balances[msg.sender];\n            p.votedNo[msg.sender] = true;\n        }\n\n        if (blocked[msg.sender] == 0) {\n            blocked[msg.sender] = _proposalID;\n        } else if (p.votingDeadline > proposals[blocked[msg.sender]].votingDeadline) {\n            // this proposal's voting deadline is further into the future than\n            // the proposal that blocks the sender so make it the blocker\n            blocked[msg.sender] = _proposalID;\n        }\n\n        Voted(_proposalID, _supportsProposal, msg.sender);\n    }\n\n\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) noEther returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        uint waitPeriod = p.newCurator\n            ? splitExecutionPeriod\n            : executeProposalPeriod;\n        // If we are over deadline and waiting period, assert proposal is closed\n        if (p.open && now > p.votingDeadline + waitPeriod) {\n            closeProposal(_proposalID);\n            return;\n        }\n\n        // Check if the proposal can be executed\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            // Have the votes been counted?\n            || !p.open\n            // Does the transaction code match the proposal?\n            || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {\n\n            throw;\n        }\n\n        // If the curator removed the recipient from the whitelist, close the proposal\n        // in order to free the deposit and allow unblocking of voters\n        if (!isRecipientAllowed(p.recipient)) {\n            closeProposal(_proposalID);\n            p.creator.send(p.proposalDeposit);\n            return;\n        }\n\n        bool proposalCheck = true;\n\n        if (p.amount > actualBalance())\n            proposalCheck = false;\n\n        uint quorum = p.yea + p.nay;\n\n        // require 53% for calling newContract()\n        if (_transactionData.length >= 4 && _transactionData[0] == 0x68\n            && _transactionData[1] == 0x37 && _transactionData[2] == 0xff\n            && _transactionData[3] == 0x1e\n            && quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {\n\n                proposalCheck = false;\n        }\n\n        if (quorum >= minQuorum(p.amount)) {\n            if (!p.creator.send(p.proposalDeposit))\n                throw;\n\n            lastTimeMinQuorumMet = now;\n            // set the minQuorum to 20% again, in the case it has been reached\n            if (quorum > totalSupply / 5)\n                minQuorumDivisor = 5;\n        }\n\n        // Execute result\n        if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {\n            if (!p.recipient.call.value(p.amount)(_transactionData))\n                throw;\n\n            p.proposalPassed = true;\n            _success = true;\n\n            // only create reward tokens when ether is not sent to the DAO itself and\n            // related addresses. Proxy addresses should be forbidden by the curator.\n            if (p.recipient != address(this) && p.recipient != address(rewardAccount)\n                && p.recipient != address(DAOrewardAccount)\n                && p.recipient != address(extraBalance)\n                && p.recipient != address(curator)) {\n\n                rewardToken[address(this)] += p.amount;\n                totalRewardToken += p.amount;\n            }\n        }\n\n        closeProposal(_proposalID);\n\n        // Initiate event\n        ProposalTallied(_proposalID, _success, quorum);\n    }\n\n\n    function closeProposal(uint _proposalID) internal {\n        Proposal p = proposals[_proposalID];\n        if (p.open)\n            sumOfProposalDeposits -= p.proposalDeposit;\n        p.open = false;\n    }\n\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) noEther onlyTokenholders returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        // Sanity check\n\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            //The request for a split expires XX days after the voting deadline\n            || now > p.votingDeadline + splitExecutionPeriod\n            // Does the new Curator address match?\n            || p.recipient != _newCurator\n            // Is it a new curator proposal?\n            || !p.newCurator\n            // Have you voted for this split?\n            || !p.votedYes[msg.sender]\n            // Did you already vote on another proposal?\n            || (blocked[msg.sender] != _proposalID && blocked[msg.sender] != 0) )  {\n\n            throw;\n        }\n\n        // If the new DAO doesn't exist yet, create the new DAO and store the\n        // current split data\n        if (address(p.splitData[0].newDAO) == 0) {\n            p.splitData[0].newDAO = createNewDAO(_newCurator);\n            // Call depth limit reached, etc.\n            if (address(p.splitData[0].newDAO) == 0)\n                throw;\n            // should never happen\n            if (this.balance < sumOfProposalDeposits)\n                throw;\n            p.splitData[0].splitBalance = actualBalance();\n            p.splitData[0].rewardToken = rewardToken[address(this)];\n            p.splitData[0].totalSupply = totalSupply;\n            p.proposalPassed = true;\n        }\n\n        // Move ether and assign new Tokens\n        uint fundsToBeMoved =\n            (balances[msg.sender] * p.splitData[0].splitBalance) /\n            p.splitData[0].totalSupply;\n        if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)\n            throw;\n\n\n        // Assign reward rights to new DAO\n        uint rewardTokenToBeMoved =\n            (balances[msg.sender] * p.splitData[0].rewardToken) /\n            p.splitData[0].totalSupply;\n\n        uint paidOutToBeMoved = DAOpaidOut[address(this)] * rewardTokenToBeMoved /\n            rewardToken[address(this)];\n\n        rewardToken[address(p.splitData[0].newDAO)] += rewardTokenToBeMoved;\n        if (rewardToken[address(this)] < rewardTokenToBeMoved)\n            throw;\n        rewardToken[address(this)] -= rewardTokenToBeMoved;\n\n        DAOpaidOut[address(p.splitData[0].newDAO)] += paidOutToBeMoved;\n        if (DAOpaidOut[address(this)] < paidOutToBeMoved)\n            throw;\n        DAOpaidOut[address(this)] -= paidOutToBeMoved;\n\n        // Burn DAO Tokens\n        Transfer(msg.sender, 0, balances[msg.sender]);\n        withdrawRewardFor(msg.sender); // be nice, and get his rewards\n        totalSupply -= balances[msg.sender];\n        balances[msg.sender] = 0;\n        paidOut[msg.sender] = 0;\n        return true;\n    }\n\n    function newContract(address _newContract){\n        if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;\n        // move all ether\n        if (!_newContract.call.value(address(this).balance)()) {\n            throw;\n        }\n\n        //move all reward tokens\n        rewardToken[_newContract] += rewardToken[address(this)];\n        rewardToken[address(this)] = 0;\n        DAOpaidOut[_newContract] += DAOpaidOut[address(this)];\n        DAOpaidOut[address(this)] = 0;\n    }\n\n\n    function retrieveDAOReward(bool _toMembers) external noEther returns (bool _success) {\n        DAO dao = DAO(msg.sender);\n\n        if ((rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken < DAOpaidOut[msg.sender])\n            throw;\n\n        uint reward =\n            (rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken - DAOpaidOut[msg.sender];\n        if(_toMembers) {\n            if (!DAOrewardAccount.payOut(dao.rewardAccount(), reward))\n                throw;\n            }\n        else {\n            if (!DAOrewardAccount.payOut(dao, reward))\n                throw;\n        }\n        DAOpaidOut[msg.sender] += reward;\n        return true;\n    }\n\n    function getMyReward() noEther returns (bool _success) {\n        return withdrawRewardFor(msg.sender);\n    }\n\n\n    function withdrawRewardFor(address _account) noEther internal returns (bool _success) {\n        if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply < paidOut[_account])\n            throw;\n\n        uint reward =\n            (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];\n        if (!rewardAccount.payOut(_account, reward))\n            throw;\n        paidOut[_account] += reward;\n        return true;\n    }\n\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(msg.sender)\n            && transferPaidOut(msg.sender, _to, _value)\n            && super.transfer(_to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferWithoutReward(address _to, uint256 _value) returns (bool success) {\n        if (!getMyReward())\n            throw;\n        return transfer(_to, _value);\n    }\n\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(_from)\n            && transferPaidOut(_from, _to, _value)\n            && super.transferFrom(_from, _to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _value\n    ) returns (bool success) {\n\n        if (!withdrawRewardFor(_from))\n            throw;\n        return transferFrom(_from, _to, _value);\n    }\n\n\n    function transferPaidOut(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal returns (bool success) {\n\n        uint transferPaidOut = paidOut[_from] * _value / balanceOf(_from);\n        if (transferPaidOut > paidOut[_from])\n            throw;\n        paidOut[_from] -= transferPaidOut;\n        paidOut[_to] += transferPaidOut;\n        return true;\n    }\n\n\n    function changeProposalDeposit(uint _proposalDeposit) noEther external {\n        if (msg.sender != address(this) || _proposalDeposit > (actualBalance() + rewardToken[address(this)])\n            / maxDepositDivisor) {\n\n            throw;\n        }\n        proposalDeposit = _proposalDeposit;\n    }\n\n\n    function changeAllowedRecipients(address _recipient, bool _allowed) noEther external returns (bool _success) {\n        if (msg.sender != curator)\n            throw;\n        allowedRecipients[_recipient] = _allowed;\n        AllowedRecipientChanged(_recipient, _allowed);\n        return true;\n    }\n\n\n    function isRecipientAllowed(address _recipient) internal returns (bool _isAllowed) {\n        if (allowedRecipients[_recipient]\n            || (_recipient == address(extraBalance)\n                // only allowed when at least the amount held in the\n                // extraBalance account has been spent from the DAO\n                && totalRewardToken > extraBalance.accumulatedInput()))\n            return true;\n        else\n            return false;\n    }\n\n    function actualBalance() constant returns (uint _actualBalance) {\n        return this.balance - sumOfProposalDeposits;\n    }\n\n\n    function minQuorum(uint _value) internal constant returns (uint _minQuorum) {\n        // minimum of 20% and maximum of 53.33%\n        return totalSupply / minQuorumDivisor +\n            (_value * totalSupply) / (3 * (actualBalance() + rewardToken[address(this)]));\n    }\n\n\n    function halveMinQuorum() returns (bool _success) {\n        // this can only be called after `quorumHalvingPeriod` has passed or at anytime\n        // by the curator with a delay of at least `minProposalDebatePeriod` between the calls\n        if ((lastTimeMinQuorumMet < (now - quorumHalvingPeriod) || msg.sender == curator)\n            && lastTimeMinQuorumMet < (now - minProposalDebatePeriod)) {\n            lastTimeMinQuorumMet = now;\n            minQuorumDivisor *= 2;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function createNewDAO(address _newCurator) internal returns (DAO _newDAO) {\n        NewCurator(_newCurator);\n        return daoCreator.createDAO(_newCurator, 0, 0, now + splitExecutionPeriod);\n    }\n\n    function numberOfProposals() constant returns (uint _numberOfProposals) {\n        // Don't count index 0. It's used by isBlocked() and exists from start\n        return proposals.length - 1;\n    }\n\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO) {\n        return proposals[_proposalID].splitData[0].newDAO;\n    }\n\n    function isBlocked(address _account) internal returns (bool) {\n        if (blocked[_account] == 0)\n            return false;\n        Proposal p = proposals[blocked[_account]];\n        if (now > p.votingDeadline) {\n            blocked[_account] = 0;\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function unblockMe() returns (bool) {\n        return isBlocked(msg.sender);\n    }\n}\n\ncontract DAO_Creator {\n    function createDAO(\n        address _curator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime\n    ) returns (DAO _newDAO) {\n\n        return new DAO(\n            _curator,\n            DAO_Creator(this),\n            _proposalDeposit,\n            _minTokensToCreate,\n            _closingTime,\n            msg.sender\n        );\n    }\n}\n",
		"ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"votingDeadline\",\"type\":\"uint256\"},{\"name\":\"open\",\"type\":\"bool\"},{\"name\":\"proposalPassed\",\"type\":\"bool\"},{\"name\":\"proposalHash\",\"type\":\"bytes32\"},{\"name\":\"proposalDeposit\",\"type\":\"uint256\"},{\"name\":\"newCurator\",\"type\":\"bool\"},{\"name\":\"yea\",\"type\":\"uint256\"},{\"name\":\"nay\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minTokensToCreate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daoCreator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"divisor\",\"outputs\":[{\"name\":\"divisor\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"extraBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"},{\"name\":\"_transactionData\",\"type\":\"bytes\"}],\"name\":\"executeProposal\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unblockMe\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRewardToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"actualBalance\",\"outputs\":[{\"name\":\"_actualBalance\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedRecipients\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferWithoutReward\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_transactionData\",\"type\":\"bytes\"},{\"name\":\"_debatingPeriod\",\"type\":\"uint256\"},{\"name\":\"_newCurator\",\"type\":\"bool\"}],\"name\":\"newProposal\",\"outputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"DAOpaidOut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minQuorumDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newContract\",\"type\":\"address\"}],\"name\":\"newContract\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"changeAllowedRecipients\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halveMinQuorum\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"paidOut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"},{\"name\":\"_newCurator\",\"type\":\"address\"}],\"name\":\"splitDAO\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAOrewardAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfProposals\",\"outputs\":[{\"name\":\"_numberOfProposals\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastTimeMinQuorumMet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toMembers\",\"type\":\"bool\"}],\"name\":\"retrieveDAOReward\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"receiveEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFueled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"createTokenProxy\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"}],\"name\":\"getNewDAOAddress\",\"outputs\":[{\"name\":\"_newDAO\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"},{\"name\":\"_supportsProposal\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[{\"name\":\"_voteID\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getMyReward\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFromWithoutReward\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalDeposit\",\"type\":\"uint256\"}],\"name\":\"changeProposalDeposit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"blocked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_transactionData\",\"type\":\"bytes\"}],\"name\":\"checkProposalCode\",\"outputs\":[{\"name\":\"_codeChecksOut\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"privateCreation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_curator\",\"type\":\"address\"},{\"name\":\"_daoCreator\",\"type\":\"address\"},{\"name\":\"_proposalDeposit\",\"type\":\"uint256\"},{\"name\":\"_minTokensToCreate\",\"type\":\"uint256\"},{\"name\":\"_closingTime\",\"type\":\"uint256\"},{\"name\":\"_privateCreation\",\"type\":\"address\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"FuelingToDate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CreatedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newCurator\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"position\",\"type\":\"bool\"},{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"quorum\",\"type\":\"uint256\"}],\"name\":\"ProposalTallied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_newCurator\",\"type\":\"address\"}],\"name\":\"NewCurator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"AllowedRecipientChanged\",\"type\":\"event\"}]",
		"ContractName": "DAO",
		"Address": "0xbb9bc244d798123fde783fcc1c72d3bb8c189413",
		"CompilerVersion": "v0.3.1-2016-04-12-3ad5e82",
		"OptimizationUsed": "1",
		"Runs": "200",
		"ConstructorArguments": "000000000000000000000000da4a4626d3e16e094de3225a751aab7128e965260000000000000000000000004a574510c7014e4ae985403536074abe582adfc80000000000000000000000000000000000000000000000001bc16d674ec80000000000000000000000000000000000000000000000000a968163f0a57b4000000000000000000000000000000000000000000000000000000000000057495e100000000000000000000000000000000000000000000000000000000000000000",
		"Library": "",
		"SwarmSource": ""
	},
	{
		"SourceCode": "pragma solidity 0.4.10;\r\n\r\n\r\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\r\n/// @author Stefan George - <stefan.george@consensys.net>\r\ncontract MultiSigWallet {\r\n\r\n    uint constant public MAX_OWNER_COUNT = 50;\r\n\r\n    event Confirmation(address indexed sender, uint indexed transactionId);\r\n    event Revocation(address indexed sender, uint indexed transactionId);\r\n    event Submission(uint indexed transactionId);\r\n    event Execution(uint indexed transactionId);\r\n    event ExecutionFailure(uint indexed transactionId);\r\n    event Deposit(address indexed sender, uint value);\r\n    event OwnerAddition(address indexed owner);\r\n    event OwnerRemoval(address indexed owner);\r\n    event RequirementChange(uint required);\r\n\r\n    mapping (uint => Transaction) public transactions;\r\n    mapping (uint => mapping (address => bool)) public confirmations;\r\n    mapping (address => bool) public isOwner;\r\n    address[] public owners;\r\n    uint public required;\r\n    uint public transactionCount;\r\n\r\n    struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bytes data;\r\n        bool executed;\r\n    }\r\n\r\n    modifier onlyWallet() {\r\n        if (msg.sender != address(this))\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier ownerDoesNotExist(address owner) {\r\n        if (isOwner[owner])\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n        if (!isOwner[owner])\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(uint transactionId) {\r\n        if (transactions[transactionId].destination == 0)\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier confirmed(uint transactionId, address owner) {\r\n        if (!confirmations[transactionId][owner])\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(uint transactionId, address owner) {\r\n        if (confirmations[transactionId][owner])\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier notExecuted(uint transactionId) {\r\n        if (transactions[transactionId].executed)\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        if (_address == 0)\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint ownerCount, uint _required) {\r\n        if (   ownerCount > MAX_OWNER_COUNT\r\n            || _required > ownerCount\r\n            || _required == 0\r\n            || ownerCount == 0)\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    /// @dev Fallback function allows to deposit ether.\r\n    function()\r\n        payable\r\n    {\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required Number of required confirmations.\r\n    function MultiSigWallet(address[] _owners, uint _required)\r\n        public\r\n        validRequirement(_owners.length, _required)\r\n    {\r\n        for (uint i=0; i<_owners.length; i++) {\r\n            if (isOwner[_owners[i]] || _owners[i] == 0)\r\n                throw;\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        owners = _owners;\r\n        required = _required;\r\n    }\r\n\r\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of new owner.\r\n    function addOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerDoesNotExist(owner)\r\n        notNull(owner)\r\n        validRequirement(owners.length + 1, required)\r\n    {\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n        OwnerAddition(owner);\r\n    }\r\n\r\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner.\r\n    function removeOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n    {\r\n        isOwner[owner] = false;\r\n        for (uint i=0; i<owners.length - 1; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n        owners.length -= 1;\r\n        if (required > owners.length)\r\n            changeRequirement(owners.length);\r\n        OwnerRemoval(owner);\r\n    }\r\n\r\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner to be replaced.\r\n    /// @param owner Address of new owner.\r\n    function replaceOwner(address owner, address newOwner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n        ownerDoesNotExist(newOwner)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = newOwner;\r\n                break;\r\n            }\r\n        isOwner[owner] = false;\r\n        isOwner[newOwner] = true;\r\n        OwnerRemoval(owner);\r\n        OwnerAddition(newOwner);\r\n    }\r\n\r\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\n    /// @param _required Number of required confirmations.\r\n    function changeRequirement(uint _required)\r\n        public\r\n        onlyWallet\r\n        validRequirement(owners.length, _required)\r\n    {\r\n        required = _required;\r\n        RequirementChange(_required);\r\n    }\r\n\r\n    /// @dev Allows an owner to submit and confirm a transaction.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function submitTransaction(address destination, uint value, bytes data)\r\n        public\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = addTransaction(destination, value, data);\r\n        confirmTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to confirm a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function confirmTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        transactionExists(transactionId)\r\n        notConfirmed(transactionId, msg.sender)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;\r\n        Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function revokeConfirmation(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        Revocation(msg.sender, transactionId);\r\n    }\r\n\r\n    /// @dev Allows anyone to execute a confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n        public\r\n        notExecuted(transactionId)\r\n    {\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction tx = transactions[transactionId];\r\n            tx.executed = true;\r\n            if (tx.destination.call.value(tx.value)(tx.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the confirmation status of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Confirmation status.\r\n    function isConfirmed(uint transactionId)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function addTransaction(address destination, uint value, bytes data)\r\n        internal\r\n        notNull(destination)\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        });\r\n        transactionCount += 1;\r\n        Submission(transactionId);\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev Returns number of confirmations of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Number of confirmations.\r\n    function getConfirmationCount(uint transactionId)\r\n        public\r\n        constant\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns total number of transactions after filers are applied.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Total number of transactions after filters are applied.\r\n    function getTransactionCount(bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns list of owners.\r\n    /// @return List of owner addresses.\r\n    function getOwners()\r\n        public\r\n        constant\r\n        returns (address[])\r\n    {\r\n        return owners;\r\n    }\r\n\r\n    /// @dev Returns array with owner addresses, which confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Returns array of owner addresses.\r\n    function getConfirmations(uint transactionId)\r\n        public\r\n        constant\r\n        returns (address[] _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        _confirmations = new address[](count);\r\n        for (i=0; i<count; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n    }\r\n\r\n    /// @dev Returns list of transaction IDs in defined range.\r\n    /// @param from Index start position of transaction array.\r\n    /// @param to Index end position of transaction array.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Returns array of transaction IDs.\r\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint[] _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i=from; i<to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }\r\n}\r\n\r\n\r\n/// @title Multisignature wallet with daily limit - Allows an owner to withdraw a daily limit without multisig.\r\n/// @author Stefan George - <stefan.george@consensys.net>\r\ncontract MultiSigWalletWithDailyLimit is MultiSigWallet {\r\n\r\n    event DailyLimitChange(uint dailyLimit);\r\n\r\n    uint public dailyLimit;\r\n    uint public lastDay;\r\n    uint public spentToday;\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n    /// @dev Contract constructor sets initial owners, required number of confirmations and daily withdraw limit.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required Number of required confirmations.\r\n    /// @param _dailyLimit Amount in wei, which can be withdrawn without confirmations on a daily basis.\r\n    function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit)\r\n        public\r\n        MultiSigWallet(_owners, _required)\r\n    {\r\n        dailyLimit = _dailyLimit;\r\n    }\r\n\r\n    /// @dev Allows to change the daily limit. Transaction has to be sent by wallet.\r\n    /// @param _dailyLimit Amount in wei.\r\n    function changeDailyLimit(uint _dailyLimit)\r\n        public\r\n        onlyWallet\r\n    {\r\n        dailyLimit = _dailyLimit;\r\n        DailyLimitChange(_dailyLimit);\r\n    }\r\n\r\n    /// @dev Allows anyone to execute a confirmed transaction or ether withdraws until daily limit is reached.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n        public\r\n        notExecuted(transactionId)\r\n    {\r\n        Transaction tx = transactions[transactionId];\r\n        bool confirmed = isConfirmed(transactionId);\r\n        if (confirmed || tx.data.length == 0 && isUnderLimit(tx.value)) {\r\n            tx.executed = true;\r\n            if (!confirmed)\r\n                spentToday += tx.value;\r\n            if (tx.destination.call.value(tx.value)(tx.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n                if (!confirmed)\r\n                    spentToday -= tx.value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n    /// @dev Returns if amount is within daily limit and resets spentToday after one day.\r\n    /// @param amount Amount to withdraw.\r\n    /// @return Returns if amount is under daily limit.\r\n    function isUnderLimit(uint amount)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (now > lastDay + 24 hours) {\r\n            lastDay = now;\r\n            spentToday = 0;\r\n        }\r\n        if (spentToday + amount > dailyLimit || spentToday + amount < spentToday)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev Returns maximum withdraw amount.\r\n    /// @return Returns amount.\r\n    function calcMaxWithdraw()\r\n        public\r\n        constant\r\n        returns (uint)\r\n    {\r\n        if (now > lastDay + 24 hours)\r\n            return dailyLimit;\r\n        if (dailyLimit < spentToday)\r\n            return 0;\r\n        return dailyLimit - spentToday;\r\n    }\r\n}",
		"ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"revokeConfirmation\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"confirmations\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calcMaxWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pending\",\"type\":\"bool\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"name\":\"getTransactionCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"isConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"getConfirmationCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"uint256\"},{\"name\":\"pending\",\"type\":\"bool\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"name\":\"getTransactionIds\",\"outputs\":[{\"name\":\"_transactionIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"getConfirmations\",\"outputs\":[{\"name\":\"_confirmations\",\"type\":\"address[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transactionCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_required\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"confirmTransaction\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"submitTransaction\",\"outputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dailyLimit\",\"type\":\"uint256\"}],\"name\":\"changeDailyLimit\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_OWNER_COUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"replaceOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_dailyLimit\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"dailyLimit\",\"type\":\"uint256\"}],\"name\":\"DailyLimitChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Revocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Submission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Execution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"ExecutionFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"RequirementChange\",\"type\":\"event\"}]",
		"ContractName": "MultiSigWalletWithDailyLimit",
		"Address": "0x851b7f3ab81bd8df354f0d7640efcd7288553419",
		"CompilerVersion": "v0.4.10+commit.f0d539ae",
		"OptimizationUsed": "0",
		"Runs": "200",
		"ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000009f7dfab2222a473284205cddf08a677726d786a00000000000000000000000005210c4dcd7eb899a1274fd6471adec9896ae05aa0000000000000000000000001d805bc00b8fa3c96ae6c8fa97b2fd24b19a9801000000000000000000000000aca7bd07a8c207f7964261c2cf1e0fbfcff37836",
		"Library": "",
		"SwarmSource": "bzzr://ea4e2bd4cd3bd1317fe18a6300906f54aea41437433d2941ccd0320c8bc088bb"
	},
	{
		"SourceCode": "# @title Serenus Coin ERC20 contract\r\n# @notice Implements https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n# @notice All mint/burn calls are acceptable only if the issuer is approved by the Factory contract\r\n# @notice Source code found at https://github.com/serenuscoin\r\n# @notice Use at your own risk\r\n# @dev Compiled with Vyper 0.1.0b8\r\n\r\n# @dev Contract interface to serenus issuer and governor\r\ncontract Issuer:\r\n    def nonce() -> int128: constant\r\n\r\ncontract Governor:\r\n    def nonce() -> int128: constant\r\n\r\n# @dev Events issued by the contract\r\nTransfer: event({_from: indexed(address), _to: indexed(address), _value: uint256(wei)})\r\nApproval: event({_owner: indexed(address), _spender: indexed(address), _value: uint256(wei)})\r\nOpenMinter: event({_newMinter: indexed(address)})\r\nCloseMinter: event({_oldMinter: indexed(address)})\r\n\r\ngovernor: Governor\r\n\r\nfactory_address: public(address)\r\n\r\nminter_addresses: public(map(address, bool))\r\nowner: public(address)\r\nname: public(bytes[12])\r\nsymbol: public(bytes[3])\r\ndecimals: public(uint256)\r\ncommission: public(uint256)\r\nbalances: public(map(address, uint256(wei)))\r\nallowances: map(address, map(address, uint256(wei)))\r\nnum_issued: uint256(wei)\r\n\r\n@public\r\ndef __init__():\r\n    self.owner = msg.sender\r\n    self.name = \"Serenus Coin\"\r\n    self.symbol = \"SRS\"\r\n    self.decimals = 18\r\n    self.commission = 10\r\n\r\n@public\r\ndef changeOwner(_address: address):\r\n    assert msg.sender == self.owner\r\n    self.owner = _address\r\n\r\n# @notice Burn tokens if the issuer is valid and the governor nonces match\r\n# @params Seller address holding tokens\r\n# @params Amount to be burnt from that address\r\n@public\r\ndef burn(_seller: address, _amount: uint256(wei)):\r\n    assert self.minter_addresses[msg.sender] == True\r\n    assert self.governor.nonce() == Issuer(msg.sender).nonce()\r\n\r\n    assert self.balances[_seller] >= _amount\r\n    self.balances[_seller] -= _amount\r\n    self.num_issued -= _amount\r\n    log.Transfer(_seller, ZERO_ADDRESS, _amount)  # log transfer event.\r\n\r\n# @notice Mint tokens if the issuer is valid and the governor nonces match\r\n# @params Buyer address to send tokens\r\n# @params Amount to be minted to that address\r\n@public\r\ndef mint(_buyer: address, _amount: uint256(wei)):\r\n    assert self.minter_addresses[msg.sender] == True\r\n    assert self.governor.nonce() == Issuer(msg.sender).nonce()\r\n    \r\n    commissionAmount: uint256(wei) = (_amount * self.commission) / 10000\r\n\r\n    self.balances[self.owner] += commissionAmount\r\n\r\n    self.balances[_buyer] += _amount - commissionAmount\r\n\r\n    self.num_issued += _amount\r\n\r\n    log.Transfer(ZERO_ADDRESS, _buyer, _amount - commissionAmount )  # log transfer event.\r\n    log.Transfer(ZERO_ADDRESS, self.owner, commissionAmount )  # log transfer event.\r\n\r\n@public\r\ndef setGovernorAddress(_address: address):\r\n    assert msg.sender == self.owner\r\n    self.governor = _address\r\n\r\n@public\r\ndef setFactoryAddress(_address: address):\r\n    assert msg.sender == self.owner\r\n    self.factory_address = _address\r\n    \r\n# @notice Set a new issuer as minter if created by the factory\r\n@public\r\ndef setMinterAddress(_new_issuer: address):\r\n    assert msg.sender == self.factory_address\r\n    self.minter_addresses[_new_issuer] = True\r\n    log.OpenMinter(_new_issuer)\r\n\r\n# @notice Remove an issuer as minter if that issuer requests it\r\n@public\r\ndef removeMinterAddress():\r\n    assert self.minter_addresses[msg.sender] == True\r\n    self.minter_addresses[msg.sender] = False\r\n    log.CloseMinter(msg.sender)\r\n    \r\n@public\r\n@constant\r\ndef totalSupply() -> uint256(wei):\r\n    return self.num_issued\r\n\r\n@public\r\n@constant\r\ndef balanceOf(_owner : address) -> uint256(wei):\r\n    return self.balances[_owner]\r\n\r\n@public\r\ndef transfer(_to : address, _value : uint256(wei)) -> bool:\r\n    _sender: address = msg.sender\r\n    self.balances[_sender] -= _value\r\n    self.balances[_to] += _value\r\n\r\n    log.Transfer(_sender, _to, _value)\r\n    return True\r\n\r\n@public\r\ndef transferFrom(_from : address, _to : address, _value : uint256(wei)) -> bool:\r\n    _sender: address = msg.sender\r\n    self.balances[_from] -= _value\r\n    self.balances[_to] += _value\r\n    self.allowances[_from][_sender] -= _value\r\n\r\n    log.Transfer(_from, _to, _value)\r\n    return True\r\n\r\n@public\r\ndef approve(_spender : address, _value : uint256(wei)) -> bool:\r\n    _sender: address = msg.sender\r\n    self.allowances[_sender][_spender] = _value\r\n\r\n    log.Approval(_sender, _spender, _value)\r\n    return True\r\n\r\n@public\r\n@constant\r\ndef allowance(_owner : address, _spender : address) -> uint256(wei):\r\n    return self.allowances[_owner][_spender]",
		"ABI": "[{\"name\":\"Transfer\",\"inputs\":[{\"type\":\"address\",\"name\":\"_from\",\"indexed\":true},{\"type\":\"address\",\"name\":\"_to\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"_value\",\"indexed\":false,\"unit\":\"wei\"}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\",\"indexed\":true},{\"type\":\"address\",\"name\":\"_spender\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"_value\",\"indexed\":false,\"unit\":\"wei\"}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"OpenMinter\",\"inputs\":[{\"type\":\"address\",\"name\":\"_newMinter\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"CloseMinter\",\"inputs\":[{\"type\":\"address\",\"name\":\"_oldMinter\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"__init__\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"constructor\"},{\"name\":\"changeOwner\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_address\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":35627},{\"name\":\"burn\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_seller\"},{\"type\":\"uint256\",\"name\":\"_amount\",\"unit\":\"wei\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":77458},{\"name\":\"mint\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_buyer\"},{\"type\":\"uint256\",\"name\":\"_amount\",\"unit\":\"wei\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":117247},{\"name\":\"setGovernorAddress\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_address\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":35717},{\"name\":\"setFactoryAddress\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_address\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":35747},{\"name\":\"setMinterAddress\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_new_issuer\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":37029},{\"name\":\"removeMinterAddress\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":22106},{\"name\":\"totalSupply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\",\"unit\":\"wei\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":693},{\"name\":\"balanceOf\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\",\"unit\":\"wei\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":895},{\"name\":\"transfer\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\",\"unit\":\"wei\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":74303},{\"name\":\"transferFrom\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\",\"unit\":\"wei\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":110172},{\"name\":\"approve\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_spender\"},{\"type\":\"uint256\",\"name\":\"_value\",\"unit\":\"wei\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":38038},{\"name\":\"allowance\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\",\"unit\":\"wei\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\"},{\"type\":\"address\",\"name\":\"_spender\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1175},{\"name\":\"factory_address\",\"outputs\":[{\"type\":\"address\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":873},{\"name\":\"minter_addresses\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1075},{\"name\":\"owner\",\"outputs\":[{\"type\":\"address\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":933},{\"name\":\"name\",\"outputs\":[{\"type\":\"bytes\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":3782},{\"name\":\"symbol\",\"outputs\":[{\"type\":\"bytes\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2471},{\"name\":\"decimals\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1023},{\"name\":\"commission\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1053},{\"name\":\"balances\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\",\"unit\":\"wei\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1255}]",
		"ContractName": "Vyper_contract",
		"Address": "0x06A981Bd291C6BFaaB9954dDcEEb782dE805b4b3",
		"CompilerVersion": "vyper:0.1.0b8",
		"OptimizationUsed": "0",
		"Runs": "0",
		"ConstructorArguments": "",
		"Library": "",
		"SwarmSource": ""
	},
	{
		"SourceCode": "pragma solidity ^0.5.3;\r\n\r\ncontract Moloch {\r\n    using SafeMath for uint256;\r\n\r\n    /***************\r\n    GLOBAL CONSTANTS\r\n    ***************/\r\n    uint256 public periodDuration; // default = 17280 = 4.8 hours in seconds (5 periods per day)\r\n    uint256 public votingPeriodLength; // default = 35 periods (7 days)\r\n    uint256 public gracePeriodLength; // default = 35 periods (7 days)\r\n    uint256 public abortWindow; // default = 5 periods (1 day)\r\n    uint256 public proposalDeposit; // default = 10 ETH (~$1,000 worth of ETH at contract deployment)\r\n    uint256 public dilutionBound; // default = 3 - maximum multiplier a YES voter will be obligated to pay in case of mass ragequit\r\n    uint256 public processingReward; // default = 0.1 - amount of ETH to give to whoever processes a proposal\r\n    uint256 public summoningTime; // needed to determine the current period\r\n\r\n    IERC20 public approvedToken; // approved token contract reference; default = wETH\r\n    GuildBank public guildBank; // guild bank contract reference\r\n\r\n    // HARD-CODED LIMITS\r\n    // These numbers are quite arbitrary; they are small enough to avoid overflows when doing calculations\r\n    // with periods or shares, yet big enough to not limit reasonable use cases.\r\n    uint256 constant MAX_VOTING_PERIOD_LENGTH = 10**18; // maximum length of voting period\r\n    uint256 constant MAX_GRACE_PERIOD_LENGTH = 10**18; // maximum length of grace period\r\n    uint256 constant MAX_DILUTION_BOUND = 10**18; // maximum dilution bound\r\n    uint256 constant MAX_NUMBER_OF_SHARES = 10**18; // maximum number of shares that can be minted\r\n\r\n    /***************\r\n    EVENTS\r\n    ***************/\r\n    event SubmitProposal(uint256 proposalIndex, address indexed delegateKey, address indexed memberAddress, address indexed applicant, uint256 tokenTribute, uint256 sharesRequested);\r\n    event SubmitVote(uint256 indexed proposalIndex, address indexed delegateKey, address indexed memberAddress, uint8 uintVote);\r\n    event ProcessProposal(uint256 indexed proposalIndex, address indexed applicant, address indexed memberAddress, uint256 tokenTribute, uint256 sharesRequested, bool didPass);\r\n    event Ragequit(address indexed memberAddress, uint256 sharesToBurn);\r\n    event Abort(uint256 indexed proposalIndex, address applicantAddress);\r\n    event UpdateDelegateKey(address indexed memberAddress, address newDelegateKey);\r\n    event SummonComplete(address indexed summoner, uint256 shares);\r\n\r\n    /******************\r\n    INTERNAL ACCOUNTING\r\n    ******************/\r\n    uint256 public totalShares = 0; // total shares across all members\r\n    uint256 public totalSharesRequested = 0; // total shares that have been requested in unprocessed proposals\r\n\r\n    enum Vote {\r\n        Null, // default value, counted as abstention\r\n        Yes,\r\n        No\r\n    }\r\n\r\n    struct Member {\r\n        address delegateKey; // the key responsible for submitting proposals and voting - defaults to member address unless updated\r\n        uint256 shares; // the # of shares assigned to this member\r\n        bool exists; // always true once a member has been created\r\n        uint256 highestIndexYesVote; // highest proposal index # on which the member voted YES\r\n    }\r\n\r\n    struct Proposal {\r\n        address proposer; // the member who submitted the proposal\r\n        address applicant; // the applicant who wishes to become a member - this key will be used for withdrawals\r\n        uint256 sharesRequested; // the # of shares the applicant is requesting\r\n        uint256 startingPeriod; // the period in which voting can start for this proposal\r\n        uint256 yesVotes; // the total number of YES votes for this proposal\r\n        uint256 noVotes; // the total number of NO votes for this proposal\r\n        bool processed; // true only if the proposal has been processed\r\n        bool didPass; // true only if the proposal passed\r\n        bool aborted; // true only if applicant calls \"abort\" fn before end of voting period\r\n        uint256 tokenTribute; // amount of tokens offered as tribute\r\n        string details; // proposal details - could be IPFS hash, plaintext, or JSON\r\n        uint256 maxTotalSharesAtYesVote; // the maximum # of total shares encountered at a yes vote on this proposal\r\n        mapping (address => Vote) votesByMember; // the votes on this proposal by each member\r\n    }\r\n\r\n    mapping (address => Member) public members;\r\n    mapping (address => address) public memberAddressByDelegateKey;\r\n    Proposal[] public proposalQueue;\r\n\r\n    /********\r\n    MODIFIERS\r\n    ********/\r\n    modifier onlyMember {\r\n        require(members[msg.sender].shares > 0, \"Moloch::onlyMember - not a member\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyDelegate {\r\n        require(members[memberAddressByDelegateKey[msg.sender]].shares > 0, \"Moloch::onlyDelegate - not a delegate\");\r\n        _;\r\n    }\r\n\r\n    /********\r\n    FUNCTIONS\r\n    ********/\r\n    constructor(\r\n        address summoner,\r\n        address _approvedToken,\r\n        uint256 _periodDuration,\r\n        uint256 _votingPeriodLength,\r\n        uint256 _gracePeriodLength,\r\n        uint256 _abortWindow,\r\n        uint256 _proposalDeposit,\r\n        uint256 _dilutionBound,\r\n        uint256 _processingReward\r\n    ) public {\r\n        require(summoner != address(0), \"Moloch::constructor - summoner cannot be 0\");\r\n        require(_approvedToken != address(0), \"Moloch::constructor - _approvedToken cannot be 0\");\r\n        require(_periodDuration > 0, \"Moloch::constructor - _periodDuration cannot be 0\");\r\n        require(_votingPeriodLength > 0, \"Moloch::constructor - _votingPeriodLength cannot be 0\");\r\n        require(_votingPeriodLength <= MAX_VOTING_PERIOD_LENGTH, \"Moloch::constructor - _votingPeriodLength exceeds limit\");\r\n        require(_gracePeriodLength <= MAX_GRACE_PERIOD_LENGTH, \"Moloch::constructor - _gracePeriodLength exceeds limit\");\r\n        require(_abortWindow > 0, \"Moloch::constructor - _abortWindow cannot be 0\");\r\n        require(_abortWindow <= _votingPeriodLength, \"Moloch::constructor - _abortWindow must be smaller than or equal to _votingPeriodLength\");\r\n        require(_dilutionBound > 0, \"Moloch::constructor - _dilutionBound cannot be 0\");\r\n        require(_dilutionBound <= MAX_DILUTION_BOUND, \"Moloch::constructor - _dilutionBound exceeds limit\");\r\n        require(_proposalDeposit >= _processingReward, \"Moloch::constructor - _proposalDeposit cannot be smaller than _processingReward\");\r\n\r\n        approvedToken = IERC20(_approvedToken);\r\n\r\n        guildBank = new GuildBank(_approvedToken);\r\n\r\n        periodDuration = _periodDuration;\r\n        votingPeriodLength = _votingPeriodLength;\r\n        gracePeriodLength = _gracePeriodLength;\r\n        abortWindow = _abortWindow;\r\n        proposalDeposit = _proposalDeposit;\r\n        dilutionBound = _dilutionBound;\r\n        processingReward = _processingReward;\r\n\r\n        summoningTime = now;\r\n\r\n        members[summoner] = Member(summoner, 1, true, 0);\r\n        memberAddressByDelegateKey[summoner] = summoner;\r\n        totalShares = 1;\r\n\r\n        emit SummonComplete(summoner, 1);\r\n    }\r\n\r\n    /*****************\r\n    PROPOSAL FUNCTIONS\r\n    *****************/\r\n\r\n    function submitProposal(\r\n        address applicant,\r\n        uint256 tokenTribute,\r\n        uint256 sharesRequested,\r\n        string memory details\r\n    )\r\n        public\r\n        onlyDelegate\r\n    {\r\n        require(applicant != address(0), \"Moloch::submitProposal - applicant cannot be 0\");\r\n\r\n        // Make sure we won't run into overflows when doing calculations with shares.\r\n        // Note that totalShares + totalSharesRequested + sharesRequested is an upper bound\r\n        // on the number of shares that can exist until this proposal has been processed.\r\n        require(totalShares.add(totalSharesRequested).add(sharesRequested) <= MAX_NUMBER_OF_SHARES, \"Moloch::submitProposal - too many shares requested\");\r\n\r\n        totalSharesRequested = totalSharesRequested.add(sharesRequested);\r\n\r\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\r\n\r\n        // collect proposal deposit from proposer and store it in the Moloch until the proposal is processed\r\n        require(approvedToken.transferFrom(msg.sender, address(this), proposalDeposit), \"Moloch::submitProposal - proposal deposit token transfer failed\");\r\n\r\n        // collect tribute from applicant and store it in the Moloch until the proposal is processed\r\n        require(approvedToken.transferFrom(applicant, address(this), tokenTribute), \"Moloch::submitProposal - tribute token transfer failed\");\r\n\r\n        // compute startingPeriod for proposal\r\n        uint256 startingPeriod = max(\r\n            getCurrentPeriod(),\r\n            proposalQueue.length == 0 ? 0 : proposalQueue[proposalQueue.length.sub(1)].startingPeriod\r\n        ).add(1);\r\n\r\n        // create proposal ...\r\n        Proposal memory proposal = Proposal({\r\n            proposer: memberAddress,\r\n            applicant: applicant,\r\n            sharesRequested: sharesRequested,\r\n            startingPeriod: startingPeriod,\r\n            yesVotes: 0,\r\n            noVotes: 0,\r\n            processed: false,\r\n            didPass: false,\r\n            aborted: false,\r\n            tokenTribute: tokenTribute,\r\n            details: details,\r\n            maxTotalSharesAtYesVote: 0\r\n        });\r\n\r\n        // ... and append it to the queue\r\n        proposalQueue.push(proposal);\r\n\r\n        uint256 proposalIndex = proposalQueue.length.sub(1);\r\n        emit SubmitProposal(proposalIndex, msg.sender, memberAddress, applicant, tokenTribute, sharesRequested);\r\n    }\r\n\r\n    function submitVote(uint256 proposalIndex, uint8 uintVote) public onlyDelegate {\r\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\r\n        Member storage member = members[memberAddress];\r\n\r\n        require(proposalIndex < proposalQueue.length, \"Moloch::submitVote - proposal does not exist\");\r\n        Proposal storage proposal = proposalQueue[proposalIndex];\r\n\r\n        require(uintVote < 3, \"Moloch::submitVote - uintVote must be less than 3\");\r\n        Vote vote = Vote(uintVote);\r\n\r\n        require(getCurrentPeriod() >= proposal.startingPeriod, \"Moloch::submitVote - voting period has not started\");\r\n        require(!hasVotingPeriodExpired(proposal.startingPeriod), \"Moloch::submitVote - proposal voting period has expired\");\r\n        require(proposal.votesByMember[memberAddress] == Vote.Null, \"Moloch::submitVote - member has already voted on this proposal\");\r\n        require(vote == Vote.Yes || vote == Vote.No, \"Moloch::submitVote - vote must be either Yes or No\");\r\n        require(!proposal.aborted, \"Moloch::submitVote - proposal has been aborted\");\r\n\r\n        // store vote\r\n        proposal.votesByMember[memberAddress] = vote;\r\n\r\n        // count vote\r\n        if (vote == Vote.Yes) {\r\n            proposal.yesVotes = proposal.yesVotes.add(member.shares);\r\n\r\n            // set highest index (latest) yes vote - must be processed for member to ragequit\r\n            if (proposalIndex > member.highestIndexYesVote) {\r\n                member.highestIndexYesVote = proposalIndex;\r\n            }\r\n\r\n            // set maximum of total shares encountered at a yes vote - used to bound dilution for yes voters\r\n            if (totalShares > proposal.maxTotalSharesAtYesVote) {\r\n                proposal.maxTotalSharesAtYesVote = totalShares;\r\n            }\r\n\r\n        } else if (vote == Vote.No) {\r\n            proposal.noVotes = proposal.noVotes.add(member.shares);\r\n        }\r\n\r\n        emit SubmitVote(proposalIndex, msg.sender, memberAddress, uintVote);\r\n    }\r\n\r\n    function processProposal(uint256 proposalIndex) public {\r\n        require(proposalIndex < proposalQueue.length, \"Moloch::processProposal - proposal does not exist\");\r\n        Proposal storage proposal = proposalQueue[proposalIndex];\r\n\r\n        require(getCurrentPeriod() >= proposal.startingPeriod.add(votingPeriodLength).add(gracePeriodLength), \"Moloch::processProposal - proposal is not ready to be processed\");\r\n        require(proposal.processed == false, \"Moloch::processProposal - proposal has already been processed\");\r\n        require(proposalIndex == 0 || proposalQueue[proposalIndex.sub(1)].processed, \"Moloch::processProposal - previous proposal must be processed\");\r\n\r\n        proposal.processed = true;\r\n        totalSharesRequested = totalSharesRequested.sub(proposal.sharesRequested);\r\n\r\n        bool didPass = proposal.yesVotes > proposal.noVotes;\r\n\r\n        // Make the proposal fail if the dilutionBound is exceeded\r\n        if (totalShares.mul(dilutionBound) < proposal.maxTotalSharesAtYesVote) {\r\n            didPass = false;\r\n        }\r\n\r\n        // PROPOSAL PASSED\r\n        if (didPass && !proposal.aborted) {\r\n\r\n            proposal.didPass = true;\r\n\r\n            // if the applicant is already a member, add to their existing shares\r\n            if (members[proposal.applicant].exists) {\r\n                members[proposal.applicant].shares = members[proposal.applicant].shares.add(proposal.sharesRequested);\r\n\r\n            // the applicant is a new member, create a new record for them\r\n            } else {\r\n                // if the applicant address is already taken by a member's delegateKey, reset it to their member address\r\n                if (members[memberAddressByDelegateKey[proposal.applicant]].exists) {\r\n                    address memberToOverride = memberAddressByDelegateKey[proposal.applicant];\r\n                    memberAddressByDelegateKey[memberToOverride] = memberToOverride;\r\n                    members[memberToOverride].delegateKey = memberToOverride;\r\n                }\r\n\r\n                // use applicant address as delegateKey by default\r\n                members[proposal.applicant] = Member(proposal.applicant, proposal.sharesRequested, true, 0);\r\n                memberAddressByDelegateKey[proposal.applicant] = proposal.applicant;\r\n            }\r\n\r\n            // mint new shares\r\n            totalShares = totalShares.add(proposal.sharesRequested);\r\n\r\n            // transfer tokens to guild bank\r\n            require(\r\n                approvedToken.transfer(address(guildBank), proposal.tokenTribute),\r\n                \"Moloch::processProposal - token transfer to guild bank failed\"\r\n            );\r\n\r\n        // PROPOSAL FAILED OR ABORTED\r\n        } else {\r\n            // return all tokens to the applicant\r\n            require(\r\n                approvedToken.transfer(proposal.applicant, proposal.tokenTribute),\r\n                \"Moloch::processProposal - failing vote token transfer failed\"\r\n            );\r\n        }\r\n\r\n        // send msg.sender the processingReward\r\n        require(\r\n            approvedToken.transfer(msg.sender, processingReward),\r\n            \"Moloch::processProposal - failed to send processing reward to msg.sender\"\r\n        );\r\n\r\n        // return deposit to proposer (subtract processing reward)\r\n        require(\r\n            approvedToken.transfer(proposal.proposer, proposalDeposit.sub(processingReward)),\r\n            \"Moloch::processProposal - failed to return proposal deposit to proposer\"\r\n        );\r\n\r\n        emit ProcessProposal(\r\n            proposalIndex,\r\n            proposal.applicant,\r\n            proposal.proposer,\r\n            proposal.tokenTribute,\r\n            proposal.sharesRequested,\r\n            didPass\r\n        );\r\n    }\r\n\r\n    function ragequit(uint256 sharesToBurn) public onlyMember {\r\n        uint256 initialTotalShares = totalShares;\r\n\r\n        Member storage member = members[msg.sender];\r\n\r\n        require(member.shares >= sharesToBurn, \"Moloch::ragequit - insufficient shares\");\r\n\r\n        require(canRagequit(member.highestIndexYesVote), \"Moloch::ragequit - cant ragequit until highest index proposal member voted YES on is processed\");\r\n\r\n        // burn shares\r\n        member.shares = member.shares.sub(sharesToBurn);\r\n        totalShares = totalShares.sub(sharesToBurn);\r\n\r\n        // instruct guildBank to transfer fair share of tokens to the ragequitter\r\n        require(\r\n            guildBank.withdraw(msg.sender, sharesToBurn, initialTotalShares),\r\n            \"Moloch::ragequit - withdrawal of tokens from guildBank failed\"\r\n        );\r\n\r\n        emit Ragequit(msg.sender, sharesToBurn);\r\n    }\r\n\r\n    function abort(uint256 proposalIndex) public {\r\n        require(proposalIndex < proposalQueue.length, \"Moloch::abort - proposal does not exist\");\r\n        Proposal storage proposal = proposalQueue[proposalIndex];\r\n\r\n        require(msg.sender == proposal.applicant, \"Moloch::abort - msg.sender must be applicant\");\r\n        require(getCurrentPeriod() < proposal.startingPeriod.add(abortWindow), \"Moloch::abort - abort window must not have passed\");\r\n        require(!proposal.aborted, \"Moloch::abort - proposal must not have already been aborted\");\r\n\r\n        uint256 tokensToAbort = proposal.tokenTribute;\r\n        proposal.tokenTribute = 0;\r\n        proposal.aborted = true;\r\n\r\n        // return all tokens to the applicant\r\n        require(\r\n            approvedToken.transfer(proposal.applicant, tokensToAbort),\r\n            \"Moloch::processProposal - failed to return tribute to applicant\"\r\n        );\r\n\r\n        emit Abort(proposalIndex, msg.sender);\r\n    }\r\n\r\n    function updateDelegateKey(address newDelegateKey) public onlyMember {\r\n        require(newDelegateKey != address(0), \"Moloch::updateDelegateKey - newDelegateKey cannot be 0\");\r\n\r\n        // skip checks if member is setting the delegate key to their member address\r\n        if (newDelegateKey != msg.sender) {\r\n            require(!members[newDelegateKey].exists, \"Moloch::updateDelegateKey - cant overwrite existing members\");\r\n            require(!members[memberAddressByDelegateKey[newDelegateKey]].exists, \"Moloch::updateDelegateKey - cant overwrite existing delegate keys\");\r\n        }\r\n\r\n        Member storage member = members[msg.sender];\r\n        memberAddressByDelegateKey[member.delegateKey] = address(0);\r\n        memberAddressByDelegateKey[newDelegateKey] = msg.sender;\r\n        member.delegateKey = newDelegateKey;\r\n\r\n        emit UpdateDelegateKey(msg.sender, newDelegateKey);\r\n    }\r\n\r\n    /***************\r\n    GETTER FUNCTIONS\r\n    ***************/\r\n\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    function getCurrentPeriod() public view returns (uint256) {\r\n        return now.sub(summoningTime).div(periodDuration);\r\n    }\r\n\r\n    function getProposalQueueLength() public view returns (uint256) {\r\n        return proposalQueue.length;\r\n    }\r\n\r\n    // can only ragequit if the latest proposal you voted YES on has been processed\r\n    function canRagequit(uint256 highestIndexYesVote) public view returns (bool) {\r\n        require(highestIndexYesVote < proposalQueue.length, \"Moloch::canRagequit - proposal does not exist\");\r\n        return proposalQueue[highestIndexYesVote].processed;\r\n    }\r\n\r\n    function hasVotingPeriodExpired(uint256 startingPeriod) public view returns (bool) {\r\n        return getCurrentPeriod() >= startingPeriod.add(votingPeriodLength);\r\n    }\r\n\r\n    function getMemberProposalVote(address memberAddress, uint256 proposalIndex) public view returns (Vote) {\r\n        require(members[memberAddress].exists, \"Moloch::getMemberProposalVote - member doesn't exist\");\r\n        require(proposalIndex < proposalQueue.length, \"Moloch::getMemberProposalVote - proposal doesn't exist\");\r\n        return proposalQueue[proposalIndex].votesByMember[memberAddress];\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract GuildBank is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    IERC20 public approvedToken; // approved token contract reference\r\n\r\n    event Withdrawal(address indexed receiver, uint256 amount);\r\n\r\n    constructor(address approvedTokenAddress) public {\r\n        approvedToken = IERC20(approvedTokenAddress);\r\n    }\r\n\r\n    function withdraw(address receiver, uint256 shares, uint256 totalShares) public onlyOwner returns (bool) {\r\n        uint256 amount = approvedToken.balanceOf(address(this)).mul(shares).div(totalShares);\r\n        emit Withdrawal(receiver, amount);\r\n        return approvedToken.transfer(receiver, amount);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}",
		"ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"processingReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"memberAddress\",\"type\":\"address\"},{\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"getMemberProposalVote\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"delegateKey\",\"type\":\"address\"},{\"name\":\"shares\",\"type\":\"uint256\"},{\"name\":\"exists\",\"type\":\"bool\"},{\"name\":\"highestIndexYesVote\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSharesRequested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDelegateKey\",\"type\":\"address\"}],\"name\":\"updateDelegateKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalQueue\",\"outputs\":[{\"name\":\"proposer\",\"type\":\"address\"},{\"name\":\"applicant\",\"type\":\"address\"},{\"name\":\"sharesRequested\",\"type\":\"uint256\"},{\"name\":\"startingPeriod\",\"type\":\"uint256\"},{\"name\":\"yesVotes\",\"type\":\"uint256\"},{\"name\":\"noVotes\",\"type\":\"uint256\"},{\"name\":\"processed\",\"type\":\"bool\"},{\"name\":\"didPass\",\"type\":\"bool\"},{\"name\":\"aborted\",\"type\":\"bool\"},{\"name\":\"tokenTribute\",\"type\":\"uint256\"},{\"name\":\"details\",\"type\":\"string\"},{\"name\":\"maxTotalSharesAtYesVote\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"memberAddressByDelegateKey\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gracePeriodLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"abortWindow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProposalQueueLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"summoningTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"votingPeriodLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sharesToBurn\",\"type\":\"uint256\"}],\"name\":\"ragequit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"startingPeriod\",\"type\":\"uint256\"}],\"name\":\"hasVotingPeriodExpired\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"applicant\",\"type\":\"address\"},{\"name\":\"tokenTribute\",\"type\":\"uint256\"},{\"name\":\"sharesRequested\",\"type\":\"uint256\"},{\"name\":\"details\",\"type\":\"string\"}],\"name\":\"submitProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"name\":\"uintVote\",\"type\":\"uint8\"}],\"name\":\"submitVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"highestIndexYesVote\",\"type\":\"uint256\"}],\"name\":\"canRagequit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"guildBank\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dilutionBound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"periodDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"approvedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"abort\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"processProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"summoner\",\"type\":\"address\"},{\"name\":\"_approvedToken\",\"type\":\"address\"},{\"name\":\"_periodDuration\",\"type\":\"uint256\"},{\"name\":\"_votingPeriodLength\",\"type\":\"uint256\"},{\"name\":\"_gracePeriodLength\",\"type\":\"uint256\"},{\"name\":\"_abortWindow\",\"type\":\"uint256\"},{\"name\":\"_proposalDeposit\",\"type\":\"uint256\"},{\"name\":\"_dilutionBound\",\"type\":\"uint256\"},{\"name\":\"_processingReward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"delegateKey\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"applicant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenTribute\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sharesRequested\",\"type\":\"uint256\"}],\"name\":\"SubmitProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"delegateKey\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"uintVote\",\"type\":\"uint8\"}],\"name\":\"SubmitVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"applicant\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenTribute\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sharesRequested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"didPass\",\"type\":\"bool\"}],\"name\":\"ProcessProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sharesToBurn\",\"type\":\"uint256\"}],\"name\":\"Ragequit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"applicantAddress\",\"type\":\"address\"}],\"name\":\"Abort\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newDelegateKey\",\"type\":\"address\"}],\"name\":\"UpdateDelegateKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"summoner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"SummonComplete\",\"type\":\"event\"}]",
		"ContractName": "Moloch",
		"Address": "0x1fd169a4f5c59acf79d0fd5d91d1201ef1bce9f1",
		"CompilerVersion": "v0.5.3+commit.10d17f24",
		"OptimizationUsed": "0",
		"Runs": "200",
		"ConstructorArguments": "000000000000000000000000512e07a093aaa20ba288392eadf03838c7a4e522000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000043800000000000000000000000000000000000000000000000000000000000000023000000000000000000000000000000000000000000000000000000000000002300000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000008ac7230489e800000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000016345785d8a0000",
		"Library": "",
		"SwarmSource": "bzzr://6363912f6cdb33033ef267bc13efdae02b703c23d90f555394addc108007d24c"
	},
	{
		"SourceCode": "// MKR Token\r\n\r\n// hevm: flattened sources of src/mkr-499.sol\r\npragma solidity ^0.4.15;\r\n\r\n////// lib/ds-roles/lib/ds-auth/src/auth.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.13; */\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    function DSAuth() public {\r\n        owner = msg.sender;\r\n        LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\n////// lib/ds-thing/lib/ds-math/src/math.sol\r\n/// math.sol -- mixin for inline numerical wizardry\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.13; */\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n////// lib/ds-thing/lib/ds-note/src/note.sol\r\n/// note.sol -- the `note' modifier, for logging calls as events\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.13; */\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint              wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n\r\n        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n////// lib/ds-thing/src/thing.sol\r\n// thing.sol - `auth` with handy mixins. your things should be DSThings\r\n\r\n// Copyright (C) 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.13; */\r\n\r\n/* import 'ds-auth/auth.sol'; */\r\n/* import 'ds-note/note.sol'; */\r\n/* import 'ds-math/math.sol'; */\r\n\r\ncontract DSThing is DSAuth, DSNote, DSMath {\r\n}\r\n\r\n////// lib/ds-token/lib/ds-stop/src/stop.sol\r\n/// stop.sol -- mixin for enable/disable functionality\r\n\r\n// Copyright (C) 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.13; */\r\n\r\n/* import \"ds-auth/auth.sol\"; */\r\n/* import \"ds-note/note.sol\"; */\r\n\r\ncontract DSStop is DSNote, DSAuth {\r\n\r\n    bool public stopped;\r\n\r\n    modifier stoppable {\r\n        require(!stopped);\r\n        _;\r\n    }\r\n    function stop() public auth note {\r\n        stopped = true;\r\n    }\r\n    function start() public auth note {\r\n        stopped = false;\r\n    }\r\n\r\n}\r\n\r\n////// lib/ds-token/lib/erc20/src/erc20.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.8; */\r\n\r\n// Token standard API\r\n// https://github.com/ethereum/EIPs/issues/20\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf( address who ) public view returns (uint value);\r\n    function allowance( address owner, address spender ) public view returns (uint _allowance);\r\n\r\n    function transfer( address to, uint value) public returns (bool ok);\r\n    function transferFrom( address from, address to, uint value) public returns (bool ok);\r\n    function approve( address spender, uint value ) public returns (bool ok);\r\n\r\n    event Transfer( address indexed from, address indexed to, uint value);\r\n    event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n////// lib/ds-token/src/base.sol\r\n/// base.sol -- basic ERC20 implementation\r\n\r\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.13; */\r\n\r\n/* import \"erc20/erc20.sol\"; */\r\n/* import \"ds-math/math.sol\"; */\r\n\r\ncontract DSTokenBase is ERC20, DSMath {\r\n    uint256                                            _supply;\r\n    mapping (address => uint256)                       _balances;\r\n    mapping (address => mapping (address => uint256))  _approvals;\r\n\r\n    function DSTokenBase(uint supply) public {\r\n        _balances[msg.sender] = supply;\r\n        _supply = supply;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return _supply;\r\n    }\r\n    function balanceOf(address src) public view returns (uint) {\r\n        return _balances[src];\r\n    }\r\n    function allowance(address src, address guy) public view returns (uint) {\r\n        return _approvals[src][guy];\r\n    }\r\n\r\n    function transfer(address dst, uint wad) public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        returns (bool)\r\n    {\r\n        if (src != msg.sender) {\r\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\r\n        }\r\n\r\n        _balances[src] = sub(_balances[src], wad);\r\n        _balances[dst] = add(_balances[dst], wad);\r\n\r\n        Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address guy, uint wad) public returns (bool) {\r\n        _approvals[msg.sender][guy] = wad;\r\n\r\n        Approval(msg.sender, guy, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n////// lib/ds-token/src/token.sol\r\n/// token.sol -- ERC20 implementation with minting and burning\r\n\r\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.13; */\r\n\r\n/* import \"ds-stop/stop.sol\"; */\r\n\r\n/* import \"./base.sol\"; */\r\n\r\ncontract DSToken is DSTokenBase(0), DSStop {\r\n\r\n    bytes32  public  symbol;\r\n    uint256  public  decimals = 18; // standard token precision. override to customize\r\n\r\n    function DSToken(bytes32 symbol_) public {\r\n        symbol = symbol_;\r\n    }\r\n\r\n    event Mint(address indexed guy, uint wad);\r\n    event Burn(address indexed guy, uint wad);\r\n\r\n    function approve(address guy) public stoppable returns (bool) {\r\n        return super.approve(guy, uint(-1));\r\n    }\r\n\r\n    function approve(address guy, uint wad) public stoppable returns (bool) {\r\n        return super.approve(guy, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        stoppable\r\n        returns (bool)\r\n    {\r\n        if (src != msg.sender && _approvals[src][msg.sender] != uint(-1)) {\r\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\r\n        }\r\n\r\n        _balances[src] = sub(_balances[src], wad);\r\n        _balances[dst] = add(_balances[dst], wad);\r\n\r\n        Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    function push(address dst, uint wad) public {\r\n        transferFrom(msg.sender, dst, wad);\r\n    }\r\n    function pull(address src, uint wad) public {\r\n        transferFrom(src, msg.sender, wad);\r\n    }\r\n    function move(address src, address dst, uint wad) public {\r\n        transferFrom(src, dst, wad);\r\n    }\r\n\r\n    function mint(uint wad) public {\r\n        mint(msg.sender, wad);\r\n    }\r\n    function burn(uint wad) public {\r\n        burn(msg.sender, wad);\r\n    }\r\n    function mint(address guy, uint wad) public auth stoppable {\r\n        _balances[guy] = add(_balances[guy], wad);\r\n        _supply = add(_supply, wad);\r\n        Mint(guy, wad);\r\n    }\r\n    function burn(address guy, uint wad) public auth stoppable {\r\n        if (guy != msg.sender && _approvals[guy][msg.sender] != uint(-1)) {\r\n            _approvals[guy][msg.sender] = sub(_approvals[guy][msg.sender], wad);\r\n        }\r\n\r\n        _balances[guy] = sub(_balances[guy], wad);\r\n        _supply = sub(_supply, wad);\r\n        Burn(guy, wad);\r\n    }\r\n\r\n    // Optional token name\r\n    bytes32   public  name = \"\";\r\n\r\n    function setName(bytes32 name_) public auth {\r\n        name = name_;\r\n    }\r\n}",
		"ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dst\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name_\",\"type\":\"bytes32\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dst\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dst\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"push\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dst\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"move\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"pull\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"symbol_\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"foo\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"bar\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fax\",\"type\":\"bytes\"}],\"name\":\"LogNote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]",
		"ContractName": "DSToken",
		"Address": "0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2",
		"CompilerVersion": "v0.4.18+commit.9cf6e910",
		"OptimizationUsed": "1",
		"Runs": "200",
		"ConstructorArguments": "4d4b520000000000000000000000000000000000000000000000000000000000",
		"Library": "",
		"SwarmSource": "bzzr://c3b70a68c1ccfc4b88f478523cfc01b3108a40e2c6d0132d5b736b0c30349728"
	},
	{
		"SourceCode": "pragma solidity ^0.4.16;\r\n\r\ncontract Token {\r\n    bytes32 public standard;\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public totalSupply;\r\n    uint8 public decimals;\r\n    bool public allowTransactions;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n}\r\n\r\ncontract Exchange {\r\n  function assert(bool assertion) {\r\n    if (!assertion) throw;\r\n  }\r\n  function safeMul(uint a, uint b) returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n  address public owner;\r\n  mapping (address => uint256) public invalidOrder;\r\n  event SetOwner(address indexed previousOwner, address indexed newOwner);\r\n  modifier onlyOwner {\r\n    assert(msg.sender == owner);\r\n    _;\r\n  }\r\n  function setOwner(address newOwner) onlyOwner {\r\n    SetOwner(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n  function getOwner() returns (address out) {\r\n    return owner;\r\n  }\r\n  function invalidateOrdersBefore(address user, uint256 nonce) onlyAdmin {\r\n    if (nonce < invalidOrder[user]) throw;\r\n    invalidOrder[user] = nonce;\r\n  }\r\n\r\n  mapping (address => mapping (address => uint256)) public tokens; //mapping of token addresses to mapping of account balances\r\n\r\n  mapping (address => bool) public admins;\r\n  mapping (address => uint256) public lastActiveTransaction;\r\n  mapping (bytes32 => uint256) public orderFills;\r\n  address public feeAccount;\r\n  uint256 public inactivityReleasePeriod;\r\n  mapping (bytes32 => bool) public traded;\r\n  mapping (bytes32 => bool) public withdrawn;\r\n  event Order(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s);\r\n  event Cancel(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s);\r\n  event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address get, address give);\r\n  event Deposit(address token, address user, uint256 amount, uint256 balance);\r\n  event Withdraw(address token, address user, uint256 amount, uint256 balance);\r\n\r\n  function setInactivityReleasePeriod(uint256 expiry) onlyAdmin returns (bool success) {\r\n    if (expiry > 1000000) throw;\r\n    inactivityReleasePeriod = expiry;\r\n    return true;\r\n  }\r\n\r\n  function Exchange(address feeAccount_) {\r\n    owner = msg.sender;\r\n    feeAccount = feeAccount_;\r\n    inactivityReleasePeriod = 100000;\r\n  }\r\n\r\n  function setAdmin(address admin, bool isAdmin) onlyOwner {\r\n    admins[admin] = isAdmin;\r\n  }\r\n\r\n  modifier onlyAdmin {\r\n    if (msg.sender != owner && !admins[msg.sender]) throw;\r\n    _;\r\n  }\r\n\r\n  function() external {\r\n    throw;\r\n  }\r\n\r\n  function depositToken(address token, uint256 amount) {\r\n    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\r\n    lastActiveTransaction[msg.sender] = block.number;\r\n    if (!Token(token).transferFrom(msg.sender, this, amount)) throw;\r\n    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n  function deposit() payable {\r\n    tokens[address(0)][msg.sender] = safeAdd(tokens[address(0)][msg.sender], msg.value);\r\n    lastActiveTransaction[msg.sender] = block.number;\r\n    Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender]);\r\n  }\r\n\r\n  function withdraw(address token, uint256 amount) returns (bool success) {\r\n    if (safeSub(block.number, lastActiveTransaction[msg.sender]) < inactivityReleasePeriod) throw;\r\n    if (tokens[token][msg.sender] < amount) throw;\r\n    tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\r\n    if (token == address(0)) {\r\n      if (!msg.sender.send(amount)) throw;\r\n    } else {\r\n      if (!Token(token).transfer(msg.sender, amount)) throw;\r\n    }\r\n    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n  function adminWithdraw(address token, uint256 amount, address user, uint256 nonce, uint8 v, bytes32 r, bytes32 s, uint256 feeWithdrawal) onlyAdmin returns (bool success) {\r\n    bytes32 hash = keccak256(this, token, amount, user, nonce);\r\n    if (withdrawn[hash]) throw;\r\n    withdrawn[hash] = true;\r\n    if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) != user) throw;\r\n    if (feeWithdrawal > 50 finney) feeWithdrawal = 50 finney;\r\n    if (tokens[token][user] < amount) throw;\r\n    tokens[token][user] = safeSub(tokens[token][user], amount);\r\n    tokens[token][feeAccount] = safeAdd(tokens[token][feeAccount], safeMul(feeWithdrawal, amount) / 1 ether);\r\n    amount = safeMul((1 ether - feeWithdrawal), amount) / 1 ether;\r\n    if (token == address(0)) {\r\n      if (!user.send(amount)) throw;\r\n    } else {\r\n      if (!Token(token).transfer(user, amount)) throw;\r\n    }\r\n    lastActiveTransaction[user] = block.number;\r\n    Withdraw(token, user, amount, tokens[token][user]);\r\n  }\r\n\r\n  function balanceOf(address token, address user) constant returns (uint256) {\r\n    return tokens[token][user];\r\n  }\r\n\r\n  function trade(uint256[8] tradeValues, address[4] tradeAddresses, uint8[2] v, bytes32[4] rs) onlyAdmin returns (bool success) {\r\n    /* amount is in amountBuy terms */\r\n    /* tradeValues\r\n       [0] amountBuy\r\n       [1] amountSell\r\n       [2] expires\r\n       [3] nonce\r\n       [4] amount\r\n       [5] tradeNonce\r\n       [6] feeMake\r\n       [7] feeTake\r\n     tradeAddressses\r\n       [0] tokenBuy\r\n       [1] tokenSell\r\n       [2] maker\r\n       [3] taker\r\n     */\r\n    if (invalidOrder[tradeAddresses[2]] > tradeValues[3]) throw;\r\n    bytes32 orderHash = keccak256(this, tradeAddresses[0], tradeValues[0], tradeAddresses[1], tradeValues[1], tradeValues[2], tradeValues[3], tradeAddresses[2]);\r\n    if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", orderHash), v[0], rs[0], rs[1]) != tradeAddresses[2]) throw;\r\n    bytes32 tradeHash = keccak256(orderHash, tradeValues[4], tradeAddresses[3], tradeValues[5]); \r\n    if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", tradeHash), v[1], rs[2], rs[3]) != tradeAddresses[3]) throw;\r\n    if (traded[tradeHash]) throw;\r\n    traded[tradeHash] = true;\r\n    if (tradeValues[6] > 100 finney) tradeValues[6] = 100 finney;\r\n    if (tradeValues[7] > 100 finney) tradeValues[7] = 100 finney;\r\n    if (safeAdd(orderFills[orderHash], tradeValues[4]) > tradeValues[0]) throw;\r\n    if (tokens[tradeAddresses[0]][tradeAddresses[3]] < tradeValues[4]) throw;\r\n    if (tokens[tradeAddresses[1]][tradeAddresses[2]] < (safeMul(tradeValues[1], tradeValues[4]) / tradeValues[0])) throw;\r\n    tokens[tradeAddresses[0]][tradeAddresses[3]] = safeSub(tokens[tradeAddresses[0]][tradeAddresses[3]], tradeValues[4]);\r\n    tokens[tradeAddresses[0]][tradeAddresses[2]] = safeAdd(tokens[tradeAddresses[0]][tradeAddresses[2]], safeMul(tradeValues[4], ((1 ether) - tradeValues[6])) / (1 ether));\r\n    tokens[tradeAddresses[0]][feeAccount] = safeAdd(tokens[tradeAddresses[0]][feeAccount], safeMul(tradeValues[4], tradeValues[6]) / (1 ether));\r\n    tokens[tradeAddresses[1]][tradeAddresses[2]] = safeSub(tokens[tradeAddresses[1]][tradeAddresses[2]], safeMul(tradeValues[1], tradeValues[4]) / tradeValues[0]);\r\n    tokens[tradeAddresses[1]][tradeAddresses[3]] = safeAdd(tokens[tradeAddresses[1]][tradeAddresses[3]], safeMul(safeMul(((1 ether) - tradeValues[7]), tradeValues[1]), tradeValues[4]) / tradeValues[0] / (1 ether));\r\n    tokens[tradeAddresses[1]][feeAccount] = safeAdd(tokens[tradeAddresses[1]][feeAccount], safeMul(safeMul(tradeValues[7], tradeValues[1]), tradeValues[4]) / tradeValues[0] / (1 ether));\r\n    orderFills[orderHash] = safeAdd(orderFills[orderHash], tradeValues[4]);\r\n    lastActiveTransaction[tradeAddresses[2]] = block.number;\r\n    lastActiveTransaction[tradeAddresses[3]] = block.number;\r\n  }\r\n}",
		"ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"assertion\",\"type\":\"bool\"}],\"name\":\"assert\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"feeWithdrawal\",\"type\":\"uint256\"}],\"name\":\"adminWithdraw\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastActiveTransaction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"withdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"},{\"name\":\"isAdmin\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"invalidOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"out\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"invalidateOrdersBefore\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"traded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"setInactivityReleasePeriod\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tradeValues\",\"type\":\"uint256[8]\"},{\"name\":\"tradeAddresses\",\"type\":\"address[4]\"},{\"name\":\"v\",\"type\":\"uint8[2]\"},{\"name\":\"rs\",\"type\":\"bytes32[4]\"}],\"name\":\"trade\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inactivityReleasePeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderFills\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"feeAccount_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"SetOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenBuy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenSell\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountSell\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expires\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"v\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"r\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"Order\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenBuy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenSell\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountSell\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expires\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"v\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"r\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenBuy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenSell\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountSell\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"get\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"give\",\"type\":\"address\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]",
		"ContractName": "Exchange",
		"Address": "0x2a0c0DBEcC7E4D658f48E01e3fA353F44050c208",
		"CompilerVersion": "v0.4.16+commit.d7661dd9",
		"OptimizationUsed": "1",
		"Runs": "200",
		"ConstructorArguments": "000000000000000000000000034767f3c519f361c5ecf46ebfc08981c629d381",
		"Library": "",
		"SwarmSource": "bzzr://11e441ee389dad20321e055f3c597af6c5b1c374e4c13ea473f285fc075e8dbc"
	},
	{
		"SourceCode": "pragma solidity ^0.4.11;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\r\n/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\r\ncontract ERC721 {\r\n    // Required methods\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n    // Optional\r\n    // function name() public view returns (string name);\r\n    // function symbol() public view returns (string symbol);\r\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\r\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\r\n\r\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\r\n}\r\n\r\n\r\n// // Auction wrapper functions\r\n\r\n\r\n// Auction wrapper functions\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title SEKRETOOOO\r\ncontract GeneScienceInterface {\r\n    /// @dev simply a boolean to indicate this is the contract we expect to be\r\n    function isGeneScience() public pure returns (bool);\r\n\r\n    /// @dev given genes of kitten 1 & 2, return a genetic combination - may have a random factor\r\n    /// @param genes1 genes of mom\r\n    /// @param genes2 genes of sire\r\n    /// @return the genes that are supposed to be passed down the child\r\n    function mixGenes(uint256 genes1, uint256 genes2, uint256 targetBlock) public returns (uint256);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title A facet of KittyCore that manages special access privileges.\r\n/// @author Axiom Zen (https://www.axiomzen.co)\r\n/// @dev See the KittyCore contract documentation to understand how the various contract facets are arranged.\r\ncontract KittyAccessControl {\r\n    // This facet controls access control for CryptoKitties. There are four roles managed here:\r\n    //\r\n    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\r\n    //         contracts. It is also the only role that can unpause the smart contract. It is initially\r\n    //         set to the address that created the smart contract in the KittyCore constructor.\r\n    //\r\n    //     - The CFO: The CFO can withdraw funds from KittyCore and its auction contracts.\r\n    //\r\n    //     - The COO: The COO can release gen0 kitties to auction, and mint promo cats.\r\n    //\r\n    // It should be noted that these roles are distinct without overlap in their access abilities, the\r\n    // abilities listed for each role above are exhaustive. In particular, while the CEO can assign any\r\n    // address to any role, the CEO address itself doesn't have the ability to act in those roles. This\r\n    // restriction is intentional so that we aren't tempted to use the CEO address frequently out of\r\n    // convenience. The less we use an address, the less likely it is that we somehow compromise the\r\n    // account.\r\n\r\n    /// @dev Emited when contract is upgraded - See README.md for updgrade plan\r\n    event ContractUpgrade(address newContract);\r\n\r\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n    address public ceoAddress;\r\n    address public cfoAddress;\r\n    address public cooAddress;\r\n\r\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\r\n    bool public paused = false;\r\n\r\n    /// @dev Access modifier for CEO-only functionality\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for CFO-only functionality\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for COO-only functionality\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCLevel() {\r\n        require(\r\n            msg.sender == cooAddress ||\r\n            msg.sender == ceoAddress ||\r\n            msg.sender == cfoAddress\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\r\n    /// @param _newCEO The address of the new CEO\r\n    function setCEO(address _newCEO) external onlyCEO {\r\n        require(_newCEO != address(0));\r\n\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\r\n    /// @param _newCFO The address of the new CFO\r\n    function setCFO(address _newCFO) external onlyCEO {\r\n        require(_newCFO != address(0));\r\n\r\n        cfoAddress = _newCFO;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\r\n    /// @param _newCOO The address of the new COO\r\n    function setCOO(address _newCOO) external onlyCEO {\r\n        require(_newCOO != address(0));\r\n\r\n        cooAddress = _newCOO;\r\n    }\r\n\r\n    /*** Pausable functionality adapted from OpenZeppelin ***/\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS paused\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by any \"C-level\" role to pause the contract. Used only when\r\n    ///  a bug or exploit is detected and we need to limit damage.\r\n    function pause() external onlyCLevel whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\r\n    ///  one reason we may pause the contract is when CFO or COO accounts are\r\n    ///  compromised.\r\n    /// @notice This is public rather than external so it can be called by\r\n    ///  derived contracts.\r\n    function unpause() public onlyCEO whenPaused {\r\n        // can't unpause if contract was upgraded\r\n        paused = false;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/// @title Base contract for CryptoKitties. Holds all common structs, events and base variables.\r\n/// @author Axiom Zen (https://www.axiomzen.co)\r\n/// @dev See the KittyCore contract documentation to understand how the various contract facets are arranged.\r\ncontract KittyBase is KittyAccessControl {\r\n    /*** EVENTS ***/\r\n\r\n    /// @dev The Birth event is fired whenever a new kitten comes into existence. This obviously\r\n    ///  includes any time a cat is created through the giveBirth method, but it is also called\r\n    ///  when a new gen0 cat is created.\r\n    event Birth(address owner, uint256 kittyId, uint256 matronId, uint256 sireId, uint256 genes);\r\n\r\n    /// @dev Transfer event as defined in current draft of ERC721. Emitted every time a kitten\r\n    ///  ownership is assigned, including births.\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n\r\n    /*** DATA TYPES ***/\r\n\r\n    /// @dev The main Kitty struct. Every cat in CryptoKitties is represented by a copy\r\n    ///  of this structure, so great care was taken to ensure that it fits neatly into\r\n    ///  exactly two 256-bit words. Note that the order of the members in this structure\r\n    ///  is important because of the byte-packing rules used by Ethereum.\r\n    ///  Ref: http://solidity.readthedocs.io/en/develop/miscellaneous.html\r\n    struct Kitty {\r\n        // The Kitty's genetic code is packed into these 256-bits, the format is\r\n        // sooper-sekret! A cat's genes never change.\r\n        uint256 genes;\r\n\r\n        // The timestamp from the block when this cat came into existence.\r\n        uint64 birthTime;\r\n\r\n        // The minimum timestamp after which this cat can engage in breeding\r\n        // activities again. This same timestamp is used for the pregnancy\r\n        // timer (for matrons) as well as the siring cooldown.\r\n        uint64 cooldownEndBlock;\r\n\r\n        // The ID of the parents of this kitty, set to 0 for gen0 cats.\r\n        // Note that using 32-bit unsigned integers limits us to a \"mere\"\r\n        // 4 billion cats. This number might seem small until you realize\r\n        // that Ethereum currently has a limit of about 500 million\r\n        // transactions per year! So, this definitely won't be a problem\r\n        // for several years (even as Ethereum learns to scale).\r\n        uint32 matronId;\r\n        uint32 sireId;\r\n\r\n        // Set to the ID of the sire cat for matrons that are pregnant,\r\n        // zero otherwise. A non-zero value here is how we know a cat\r\n        // is pregnant. Used to retrieve the genetic material for the new\r\n        // kitten when the birth transpires.\r\n        uint32 siringWithId;\r\n\r\n        // Set to the index in the cooldown array (see below) that represents\r\n        // the current cooldown duration for this Kitty. This starts at zero\r\n        // for gen0 cats, and is initialized to floor(generation/2) for others.\r\n        // Incremented by one for each successful breeding action, regardless\r\n        // of whether this cat is acting as matron or sire.\r\n        uint16 cooldownIndex;\r\n\r\n        // The \"generation number\" of this cat. Cats minted by the CK contract\r\n        // for sale are called \"gen0\" and have a generation number of 0. The\r\n        // generation number of all other cats is the larger of the two generation\r\n        // numbers of their parents, plus one.\r\n        // (i.e. max(matron.generation, sire.generation) + 1)\r\n        uint16 generation;\r\n    }\r\n\r\n    /*** CONSTANTS ***/\r\n\r\n    /// @dev A lookup table indicating the cooldown duration after any successful\r\n    ///  breeding action, called \"pregnancy time\" for matrons and \"siring cooldown\"\r\n    ///  for sires. Designed such that the cooldown roughly doubles each time a cat\r\n    ///  is bred, encouraging owners not to just keep breeding the same cat over\r\n    ///  and over again. Caps out at one week (a cat can breed an unbounded number\r\n    ///  of times, and the maximum cooldown is always seven days).\r\n    uint32[14] public cooldowns = [\r\n        uint32(1 minutes),\r\n        uint32(2 minutes),\r\n        uint32(5 minutes),\r\n        uint32(10 minutes),\r\n        uint32(30 minutes),\r\n        uint32(1 hours),\r\n        uint32(2 hours),\r\n        uint32(4 hours),\r\n        uint32(8 hours),\r\n        uint32(16 hours),\r\n        uint32(1 days),\r\n        uint32(2 days),\r\n        uint32(4 days),\r\n        uint32(7 days)\r\n    ];\r\n\r\n    // An approximation of currently how many seconds are in between blocks.\r\n    uint256 public secondsPerBlock = 15;\r\n\r\n    /*** STORAGE ***/\r\n\r\n    /// @dev An array containing the Kitty struct for all Kitties in existence. The ID\r\n    ///  of each cat is actually an index into this array. Note that ID 0 is a negacat,\r\n    ///  the unKitty, the mythical beast that is the parent of all gen0 cats. A bizarre\r\n    ///  creature that is both matron and sire... to itself! Has an invalid genetic code.\r\n    ///  In other words, cat ID 0 is invalid... ;-)\r\n    Kitty[] kitties;\r\n\r\n    /// @dev A mapping from cat IDs to the address that owns them. All cats have\r\n    ///  some valid owner address, even gen0 cats are created with a non-zero owner.\r\n    mapping (uint256 => address) public kittyIndexToOwner;\r\n\r\n    // @dev A mapping from owner address to count of tokens that address owns.\r\n    //  Used internally inside balanceOf() to resolve ownership count.\r\n    mapping (address => uint256) ownershipTokenCount;\r\n\r\n    /// @dev A mapping from KittyIDs to an address that has been approved to call\r\n    ///  transferFrom(). Each Kitty can only have one approved address for transfer\r\n    ///  at any time. A zero value means no approval is outstanding.\r\n    mapping (uint256 => address) public kittyIndexToApproved;\r\n\r\n    /// @dev A mapping from KittyIDs to an address that has been approved to use\r\n    ///  this Kitty for siring via breedWith(). Each Kitty can only have one approved\r\n    ///  address for siring at any time. A zero value means no approval is outstanding.\r\n    mapping (uint256 => address) public sireAllowedToAddress;\r\n\r\n    /// @dev The address of the ClockAuction contract that handles sales of Kitties. This\r\n    ///  same contract handles both peer-to-peer sales as well as the gen0 sales which are\r\n    ///  initiated every 15 minutes.\r\n    SaleClockAuction public saleAuction;\r\n\r\n    /// @dev The address of a custom ClockAuction subclassed contract that handles siring\r\n    ///  auctions. Needs to be separate from saleAuction because the actions taken on success\r\n    ///  after a sales and siring auction are quite different.\r\n    SiringClockAuction public siringAuction;\r\n\r\n    /// @dev Assigns ownership of a specific Kitty to an address.\r\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n        // Since the number of kittens is capped to 2^32 we can't overflow this\r\n        ownershipTokenCount[_to]++;\r\n        // transfer ownership\r\n        kittyIndexToOwner[_tokenId] = _to;\r\n        // When creating new kittens _from is 0x0, but we can't account that address.\r\n        if (_from != address(0)) {\r\n            ownershipTokenCount[_from]--;\r\n            // once the kitten is transferred also clear sire allowances\r\n            delete sireAllowedToAddress[_tokenId];\r\n            // clear any previously approved ownership exchange\r\n            delete kittyIndexToApproved[_tokenId];\r\n        }\r\n        // Emit the transfer event.\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /// @dev An internal method that creates a new kitty and stores it. This\r\n    ///  method doesn't do any checking and should only be called when the\r\n    ///  input data is known to be valid. Will generate both a Birth event\r\n    ///  and a Transfer event.\r\n    /// @param _matronId The kitty ID of the matron of this cat (zero for gen0)\r\n    /// @param _sireId The kitty ID of the sire of this cat (zero for gen0)\r\n    /// @param _generation The generation number of this cat, must be computed by caller.\r\n    /// @param _genes The kitty's genetic code.\r\n    /// @param _owner The inital owner of this cat, must be non-zero (except for the unKitty, ID 0)\r\n    function _createKitty(\r\n        uint256 _matronId,\r\n        uint256 _sireId,\r\n        uint256 _generation,\r\n        uint256 _genes,\r\n        address _owner\r\n    )\r\n        internal\r\n        returns (uint)\r\n    {\r\n        // These requires are not strictly necessary, our calling code should make\r\n        // sure that these conditions are never broken. However! _createKitty() is already\r\n        // an expensive call (for storage), and it doesn't hurt to be especially careful\r\n        // to ensure our data structures are always valid.\r\n        require(_matronId == uint256(uint32(_matronId)));\r\n        require(_sireId == uint256(uint32(_sireId)));\r\n        require(_generation == uint256(uint16(_generation)));\r\n\r\n        // New kitty starts with the same cooldown as parent gen/2\r\n        uint16 cooldownIndex = uint16(_generation / 2);\r\n        if (cooldownIndex > 13) {\r\n            cooldownIndex = 13;\r\n        }\r\n\r\n        Kitty memory _kitty = Kitty({\r\n            genes: _genes,\r\n            birthTime: uint64(now),\r\n            cooldownEndBlock: 0,\r\n            matronId: uint32(_matronId),\r\n            sireId: uint32(_sireId),\r\n            siringWithId: 0,\r\n            cooldownIndex: cooldownIndex,\r\n            generation: uint16(_generation)\r\n        });\r\n        uint256 newKittenId = kitties.push(_kitty) - 1;\r\n\r\n        // It's probably never going to happen, 4 billion cats is A LOT, but\r\n        // let's just be 100% sure we never let this happen.\r\n        require(newKittenId == uint256(uint32(newKittenId)));\r\n\r\n        // emit the birth event\r\n        Birth(\r\n            _owner,\r\n            newKittenId,\r\n            uint256(_kitty.matronId),\r\n            uint256(_kitty.sireId),\r\n            _kitty.genes\r\n        );\r\n\r\n        // This will assign ownership, and also emit the Transfer event as\r\n        // per ERC721 draft\r\n        _transfer(0, _owner, newKittenId);\r\n\r\n        return newKittenId;\r\n    }\r\n\r\n    // Any C-level can fix how many seconds per blocks are currently observed.\r\n    function setSecondsPerBlock(uint256 secs) external onlyCLevel {\r\n        require(secs < cooldowns[0]);\r\n        secondsPerBlock = secs;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @title The external contract that is responsible for generating metadata for the kitties,\r\n///  it has one function that will return the data as bytes.\r\ncontract ERC721Metadata {\r\n    /// @dev Given a token Id, returns a byte array that is supposed to be converted into string.\r\n    function getMetadata(uint256 _tokenId, string) public view returns (bytes32[4] buffer, uint256 count) {\r\n        if (_tokenId == 1) {\r\n            buffer[0] = \"Hello World! :D\";\r\n            count = 15;\r\n        } else if (_tokenId == 2) {\r\n            buffer[0] = \"I would definitely choose a medi\";\r\n            buffer[1] = \"um length string.\";\r\n            count = 49;\r\n        } else if (_tokenId == 3) {\r\n            buffer[0] = \"Lorem ipsum dolor sit amet, mi e\";\r\n            buffer[1] = \"st accumsan dapibus augue lorem,\";\r\n            buffer[2] = \" tristique vestibulum id, libero\";\r\n            buffer[3] = \" suscipit varius sapien aliquam.\";\r\n            count = 128;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/// @title The facet of the CryptoKitties core contract that manages ownership, ERC-721 (draft) compliant.\r\n/// @author Axiom Zen (https://www.axiomzen.co)\r\n/// @dev Ref: https://github.com/ethereum/EIPs/issues/721\r\n///  See the KittyCore contract documentation to understand how the various contract facets are arranged.\r\ncontract KittyOwnership is KittyBase, ERC721 {\r\n\r\n    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\r\n    string public constant name = \"CryptoKitties\";\r\n    string public constant symbol = \"CK\";\r\n\r\n    // The contract that will return kitty metadata\r\n    ERC721Metadata public erc721Metadata;\r\n\r\n    bytes4 constant InterfaceSignature_ERC165 =\r\n        bytes4(keccak256('supportsInterface(bytes4)'));\r\n\r\n    bytes4 constant InterfaceSignature_ERC721 =\r\n        bytes4(keccak256('name()')) ^\r\n        bytes4(keccak256('symbol()')) ^\r\n        bytes4(keccak256('totalSupply()')) ^\r\n        bytes4(keccak256('balanceOf(address)')) ^\r\n        bytes4(keccak256('ownerOf(uint256)')) ^\r\n        bytes4(keccak256('approve(address,uint256)')) ^\r\n        bytes4(keccak256('transfer(address,uint256)')) ^\r\n        bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n        bytes4(keccak256('tokensOfOwner(address)')) ^\r\n        bytes4(keccak256('tokenMetadata(uint256,string)'));\r\n\r\n    /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\r\n    ///  Returns true for any standardized interfaces implemented by this contract. We implement\r\n    ///  ERC-165 (obviously!) and ERC-721.\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\r\n    {\r\n        // DEBUG ONLY\r\n        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9a20483d));\r\n\r\n        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\r\n    }\r\n\r\n    /// @dev Set the address of the sibling contract that tracks metadata.\r\n    ///  CEO only.\r\n    function setMetadataAddress(address _contractAddress) public onlyCEO {\r\n        erc721Metadata = ERC721Metadata(_contractAddress);\r\n    }\r\n\r\n    // Internal utility functions: These functions all assume that their input arguments\r\n    // are valid. We leave it to public methods to sanitize their inputs and follow\r\n    // the required logic.\r\n\r\n    /// @dev Checks if a given address is the current owner of a particular Kitty.\r\n    /// @param _claimant the address we are validating against.\r\n    /// @param _tokenId kitten id, only valid when > 0\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return kittyIndexToOwner[_tokenId] == _claimant;\r\n    }\r\n\r\n    /// @dev Checks if a given address currently has transferApproval for a particular Kitty.\r\n    /// @param _claimant the address we are confirming kitten is approved for.\r\n    /// @param _tokenId kitten id, only valid when > 0\r\n    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return kittyIndexToApproved[_tokenId] == _claimant;\r\n    }\r\n\r\n    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous\r\n    ///  approval. Setting _approved to address(0) clears all transfer approval.\r\n    ///  NOTE: _approve() does NOT send the Approval event. This is intentional because\r\n    ///  _approve() and transferFrom() are used together for putting Kitties on auction, and\r\n    ///  there is no value in spamming the log with Approval events in that case.\r\n    function _approve(uint256 _tokenId, address _approved) internal {\r\n        kittyIndexToApproved[_tokenId] = _approved;\r\n    }\r\n\r\n    /// @notice Returns the number of Kitties owned by a specific address.\r\n    /// @param _owner The owner address to check.\r\n    /// @dev Required for ERC-721 compliance\r\n    function balanceOf(address _owner) public view returns (uint256 count) {\r\n        return ownershipTokenCount[_owner];\r\n    }\r\n\r\n    /// @notice Transfers a Kitty to another address. If transferring to a smart\r\n    ///  contract be VERY CAREFUL to ensure that it is aware of ERC-721 (or\r\n    ///  CryptoKitties specifically) or your Kitty may be lost forever. Seriously.\r\n    /// @param _to The address of the recipient, can be a user or contract.\r\n    /// @param _tokenId The ID of the Kitty to transfer.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function transfer(\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n        // Disallow transfers to this contract to prevent accidental misuse.\r\n        // The contract should never own any kitties (except very briefly\r\n        // after a gen0 cat is created and before it goes on auction).\r\n        require(_to != address(this));\r\n        // Disallow transfers to the auction contracts to prevent accidental\r\n        // misuse. Auction contracts should only take ownership of kitties\r\n        // through the allow + transferFrom flow.\r\n        require(_to != address(saleAuction));\r\n        require(_to != address(siringAuction));\r\n\r\n        // You can only send your own cat.\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        // Reassign ownership, clear pending approvals, emit Transfer event.\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    /// @notice Grant another address the right to transfer a specific Kitty via\r\n    ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.\r\n    /// @param _to The address to be granted transfer approval. Pass address(0) to\r\n    ///  clear all approvals.\r\n    /// @param _tokenId The ID of the Kitty that can be transferred if this call succeeds.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function approve(\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        // Only an owner can grant transfer approval.\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        // Register the approval (replacing any previous approval).\r\n        _approve(_tokenId, _to);\r\n\r\n        // Emit approval event.\r\n        Approval(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    /// @notice Transfer a Kitty owned by another address, for which the calling address\r\n    ///  has previously been granted transfer approval by the owner.\r\n    /// @param _from The address that owns the Kitty to be transfered.\r\n    /// @param _to The address that should take ownership of the Kitty. Can be any address,\r\n    ///  including the caller.\r\n    /// @param _tokenId The ID of the Kitty to be transferred.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n        // Disallow transfers to this contract to prevent accidental misuse.\r\n        // The contract should never own any kitties (except very briefly\r\n        // after a gen0 cat is created and before it goes on auction).\r\n        require(_to != address(this));\r\n        // Check for approval and valid ownership\r\n        require(_approvedFor(msg.sender, _tokenId));\r\n        require(_owns(_from, _tokenId));\r\n\r\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /// @notice Returns the total number of Kitties currently in existence.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function totalSupply() public view returns (uint) {\r\n        return kitties.length - 1;\r\n    }\r\n\r\n    /// @notice Returns the address currently assigned ownership of a given Kitty.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function ownerOf(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (address owner)\r\n    {\r\n        owner = kittyIndexToOwner[_tokenId];\r\n\r\n        require(owner != address(0));\r\n    }\r\n\r\n    /// @notice Returns a list of all Kitty IDs assigned to an address.\r\n    /// @param _owner The owner whose Kitties we are interested in.\r\n    /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\r\n    ///  expensive (it walks the entire Kitty array looking for cats belonging to owner),\r\n    ///  but it also returns a dynamic array, which is only supported for web3 calls, and\r\n    ///  not contract-to-contract calls.\r\n    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\r\n        uint256 tokenCount = balanceOf(_owner);\r\n\r\n        if (tokenCount == 0) {\r\n            // Return an empty array\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](tokenCount);\r\n            uint256 totalCats = totalSupply();\r\n            uint256 resultIndex = 0;\r\n\r\n            // We count on the fact that all cats have IDs starting at 1 and increasing\r\n            // sequentially up to the totalCat count.\r\n            uint256 catId;\r\n\r\n            for (catId = 1; catId <= totalCats; catId++) {\r\n                if (kittyIndexToOwner[catId] == _owner) {\r\n                    result[resultIndex] = catId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /// @dev Adapted from memcpy() by @arachnid (Nick Johnson <arachnid@notdot.net>)\r\n    ///  This method is licenced under the Apache License.\r\n    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\r\n    function _memcpy(uint _dest, uint _src, uint _len) private view {\r\n        // Copy word-length chunks while possible\r\n        for(; _len >= 32; _len -= 32) {\r\n            assembly {\r\n                mstore(_dest, mload(_src))\r\n            }\r\n            _dest += 32;\r\n            _src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint256 mask = 256 ** (32 - _len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(_src), not(mask))\r\n            let destpart := and(mload(_dest), mask)\r\n            mstore(_dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /// @dev Adapted from toString(slice) by @arachnid (Nick Johnson <arachnid@notdot.net>)\r\n    ///  This method is licenced under the Apache License.\r\n    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\r\n    function _toString(bytes32[4] _rawBytes, uint256 _stringLength) private view returns (string) {\r\n        var outputString = new string(_stringLength);\r\n        uint256 outputPtr;\r\n        uint256 bytesPtr;\r\n\r\n        assembly {\r\n            outputPtr := add(outputString, 32)\r\n            bytesPtr := _rawBytes\r\n        }\r\n\r\n        _memcpy(outputPtr, bytesPtr, _stringLength);\r\n\r\n        return outputString;\r\n    }\r\n\r\n    /// @notice Returns a URI pointing to a metadata package for this token conforming to\r\n    ///  ERC-721 (https://github.com/ethereum/EIPs/issues/721)\r\n    /// @param _tokenId The ID number of the Kitty whose metadata should be returned.\r\n    function tokenMetadata(uint256 _tokenId, string _preferredTransport) external view returns (string infoUrl) {\r\n        require(erc721Metadata != address(0));\r\n        bytes32[4] memory buffer;\r\n        uint256 count;\r\n        (buffer, count) = erc721Metadata.getMetadata(_tokenId, _preferredTransport);\r\n\r\n        return _toString(buffer, count);\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title A facet of KittyCore that manages Kitty siring, gestation, and birth.\r\n/// @author Axiom Zen (https://www.axiomzen.co)\r\n/// @dev See the KittyCore contract documentation to understand how the various contract facets are arranged.\r\ncontract KittyBreeding is KittyOwnership {\r\n\r\n    /// @dev The Pregnant event is fired when two cats successfully breed and the pregnancy\r\n    ///  timer begins for the matron.\r\n    event Pregnant(address owner, uint256 matronId, uint256 sireId, uint256 cooldownEndBlock);\r\n\r\n    /// @notice The minimum payment required to use breedWithAuto(). This fee goes towards\r\n    ///  the gas cost paid by whatever calls giveBirth(), and can be dynamically updated by\r\n    ///  the COO role as the gas price changes.\r\n    uint256 public autoBirthFee = 2 finney;\r\n\r\n    // Keeps track of number of pregnant kitties.\r\n    uint256 public pregnantKitties;\r\n\r\n    /// @dev The address of the sibling contract that is used to implement the sooper-sekret\r\n    ///  genetic combination algorithm.\r\n    GeneScienceInterface public geneScience;\r\n\r\n    /// @dev Update the address of the genetic contract, can only be called by the CEO.\r\n    /// @param _address An address of a GeneScience contract instance to be used from this point forward.\r\n    function setGeneScienceAddress(address _address) external onlyCEO {\r\n        GeneScienceInterface candidateContract = GeneScienceInterface(_address);\r\n\r\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\r\n        require(candidateContract.isGeneScience());\r\n\r\n        // Set the new contract address\r\n        geneScience = candidateContract;\r\n    }\r\n\r\n    /// @dev Checks that a given kitten is able to breed. Requires that the\r\n    ///  current cooldown is finished (for sires) and also checks that there is\r\n    ///  no pending pregnancy.\r\n    function _isReadyToBreed(Kitty _kit) internal view returns (bool) {\r\n        // In addition to checking the cooldownEndBlock, we also need to check to see if\r\n        // the cat has a pending birth; there can be some period of time between the end\r\n        // of the pregnacy timer and the birth event.\r\n        return (_kit.siringWithId == 0) && (_kit.cooldownEndBlock <= uint64(block.number));\r\n    }\r\n\r\n    /// @dev Check if a sire has authorized breeding with this matron. True if both sire\r\n    ///  and matron have the same owner, or if the sire has given siring permission to\r\n    ///  the matron's owner (via approveSiring()).\r\n    function _isSiringPermitted(uint256 _sireId, uint256 _matronId) internal view returns (bool) {\r\n        address matronOwner = kittyIndexToOwner[_matronId];\r\n        address sireOwner = kittyIndexToOwner[_sireId];\r\n\r\n        // Siring is okay if they have same owner, or if the matron's owner was given\r\n        // permission to breed with this sire.\r\n        return (matronOwner == sireOwner || sireAllowedToAddress[_sireId] == matronOwner);\r\n    }\r\n\r\n    /// @dev Set the cooldownEndTime for the given Kitty, based on its current cooldownIndex.\r\n    ///  Also increments the cooldownIndex (unless it has hit the cap).\r\n    /// @param _kitten A reference to the Kitty in storage which needs its timer started.\r\n    function _triggerCooldown(Kitty storage _kitten) internal {\r\n        // Compute an estimation of the cooldown time in blocks (based on current cooldownIndex).\r\n        _kitten.cooldownEndBlock = uint64((cooldowns[_kitten.cooldownIndex]/secondsPerBlock) + block.number);\r\n\r\n        // Increment the breeding count, clamping it at 13, which is the length of the\r\n        // cooldowns array. We could check the array size dynamically, but hard-coding\r\n        // this as a constant saves gas. Yay, Solidity!\r\n        if (_kitten.cooldownIndex < 13) {\r\n            _kitten.cooldownIndex += 1;\r\n        }\r\n    }\r\n\r\n    /// @notice Grants approval to another user to sire with one of your Kitties.\r\n    /// @param _addr The address that will be able to sire with your Kitty. Set to\r\n    ///  address(0) to clear all siring approvals for this Kitty.\r\n    /// @param _sireId A Kitty that you own that _addr will now be able to sire with.\r\n    function approveSiring(address _addr, uint256 _sireId)\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_owns(msg.sender, _sireId));\r\n        sireAllowedToAddress[_sireId] = _addr;\r\n    }\r\n\r\n    /// @dev Updates the minimum payment required for calling giveBirthAuto(). Can only\r\n    ///  be called by the COO address. (This fee is used to offset the gas cost incurred\r\n    ///  by the autobirth daemon).\r\n    function setAutoBirthFee(uint256 val) external onlyCOO {\r\n        autoBirthFee = val;\r\n    }\r\n\r\n    /// @dev Checks to see if a given Kitty is pregnant and (if so) if the gestation\r\n    ///  period has passed.\r\n    function _isReadyToGiveBirth(Kitty _matron) private view returns (bool) {\r\n        return (_matron.siringWithId != 0) && (_matron.cooldownEndBlock <= uint64(block.number));\r\n    }\r\n\r\n    /// @notice Checks that a given kitten is able to breed (i.e. it is not pregnant or\r\n    ///  in the middle of a siring cooldown).\r\n    /// @param _kittyId reference the id of the kitten, any user can inquire about it\r\n    function isReadyToBreed(uint256 _kittyId)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(_kittyId > 0);\r\n        Kitty storage kit = kitties[_kittyId];\r\n        return _isReadyToBreed(kit);\r\n    }\r\n\r\n    /// @dev Checks whether a kitty is currently pregnant.\r\n    /// @param _kittyId reference the id of the kitten, any user can inquire about it\r\n    function isPregnant(uint256 _kittyId)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(_kittyId > 0);\r\n        // A kitty is pregnant if and only if this field is set\r\n        return kitties[_kittyId].siringWithId != 0;\r\n    }\r\n\r\n    /// @dev Internal check to see if a given sire and matron are a valid mating pair. DOES NOT\r\n    ///  check ownership permissions (that is up to the caller).\r\n    /// @param _matron A reference to the Kitty struct of the potential matron.\r\n    /// @param _matronId The matron's ID.\r\n    /// @param _sire A reference to the Kitty struct of the potential sire.\r\n    /// @param _sireId The sire's ID\r\n    function _isValidMatingPair(\r\n        Kitty storage _matron,\r\n        uint256 _matronId,\r\n        Kitty storage _sire,\r\n        uint256 _sireId\r\n    )\r\n        private\r\n        view\r\n        returns(bool)\r\n    {\r\n        // A Kitty can't breed with itself!\r\n        if (_matronId == _sireId) {\r\n            return false;\r\n        }\r\n\r\n        // Kitties can't breed with their parents.\r\n        if (_matron.matronId == _sireId || _matron.sireId == _sireId) {\r\n            return false;\r\n        }\r\n        if (_sire.matronId == _matronId || _sire.sireId == _matronId) {\r\n            return false;\r\n        }\r\n\r\n        // We can short circuit the sibling check (below) if either cat is\r\n        // gen zero (has a matron ID of zero).\r\n        if (_sire.matronId == 0 || _matron.matronId == 0) {\r\n            return true;\r\n        }\r\n\r\n        // Kitties can't breed with full or half siblings.\r\n        if (_sire.matronId == _matron.matronId || _sire.matronId == _matron.sireId) {\r\n            return false;\r\n        }\r\n        if (_sire.sireId == _matron.matronId || _sire.sireId == _matron.sireId) {\r\n            return false;\r\n        }\r\n\r\n        // Everything seems cool! Let's get DTF.\r\n        return true;\r\n    }\r\n\r\n    /// @dev Internal check to see if a given sire and matron are a valid mating pair for\r\n    ///  breeding via auction (i.e. skips ownership and siring approval checks).\r\n    function _canBreedWithViaAuction(uint256 _matronId, uint256 _sireId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        Kitty storage matron = kitties[_matronId];\r\n        Kitty storage sire = kitties[_sireId];\r\n        return _isValidMatingPair(matron, _matronId, sire, _sireId);\r\n    }\r\n\r\n    /// @notice Checks to see if two cats can breed together, including checks for\r\n    ///  ownership and siring approvals. Does NOT check that both cats are ready for\r\n    ///  breeding (i.e. breedWith could still fail until the cooldowns are finished).\r\n    ///  TODO: Shouldn't this check pregnancy and cooldowns?!?\r\n    /// @param _matronId The ID of the proposed matron.\r\n    /// @param _sireId The ID of the proposed sire.\r\n    function canBreedWith(uint256 _matronId, uint256 _sireId)\r\n        external\r\n        view\r\n        returns(bool)\r\n    {\r\n        require(_matronId > 0);\r\n        require(_sireId > 0);\r\n        Kitty storage matron = kitties[_matronId];\r\n        Kitty storage sire = kitties[_sireId];\r\n        return _isValidMatingPair(matron, _matronId, sire, _sireId) &&\r\n            _isSiringPermitted(_sireId, _matronId);\r\n    }\r\n\r\n    /// @dev Internal utility function to initiate breeding, assumes that all breeding\r\n    ///  requirements have been checked.\r\n    function _breedWith(uint256 _matronId, uint256 _sireId) internal {\r\n        // Grab a reference to the Kitties from storage.\r\n        Kitty storage sire = kitties[_sireId];\r\n        Kitty storage matron = kitties[_matronId];\r\n\r\n        // Mark the matron as pregnant, keeping track of who the sire is.\r\n        matron.siringWithId = uint32(_sireId);\r\n\r\n        // Trigger the cooldown for both parents.\r\n        _triggerCooldown(sire);\r\n        _triggerCooldown(matron);\r\n\r\n        // Clear siring permission for both parents. This may not be strictly necessary\r\n        // but it's likely to avoid confusion!\r\n        delete sireAllowedToAddress[_matronId];\r\n        delete sireAllowedToAddress[_sireId];\r\n\r\n        // Every time a kitty gets pregnant, counter is incremented.\r\n        pregnantKitties++;\r\n\r\n        // Emit the pregnancy event.\r\n        Pregnant(kittyIndexToOwner[_matronId], _matronId, _sireId, matron.cooldownEndBlock);\r\n    }\r\n\r\n    /// @notice Breed a Kitty you own (as matron) with a sire that you own, or for which you\r\n    ///  have previously been given Siring approval. Will either make your cat pregnant, or will\r\n    ///  fail entirely. Requires a pre-payment of the fee given out to the first caller of giveBirth()\r\n    /// @param _matronId The ID of the Kitty acting as matron (will end up pregnant if successful)\r\n    /// @param _sireId The ID of the Kitty acting as sire (will begin its siring cooldown if successful)\r\n    function breedWithAuto(uint256 _matronId, uint256 _sireId)\r\n        external\r\n        payable\r\n        whenNotPaused\r\n    {\r\n        // Checks for payment.\r\n        require(msg.value >= autoBirthFee);\r\n\r\n        // Caller must own the matron.\r\n        require(_owns(msg.sender, _matronId));\r\n\r\n        // Neither sire nor matron are allowed to be on auction during a normal\r\n        // breeding operation, but we don't need to check that explicitly.\r\n        // For matron: The caller of this function can't be the owner of the matron\r\n        //   because the owner of a Kitty on auction is the auction house, and the\r\n        //   auction house will never call breedWith().\r\n        // For sire: Similarly, a sire on auction will be owned by the auction house\r\n        //   and the act of transferring ownership will have cleared any oustanding\r\n        //   siring approval.\r\n        // Thus we don't need to spend gas explicitly checking to see if either cat\r\n        // is on auction.\r\n\r\n        // Check that matron and sire are both owned by caller, or that the sire\r\n        // has given siring permission to caller (i.e. matron's owner).\r\n        // Will fail for _sireId = 0\r\n        require(_isSiringPermitted(_sireId, _matronId));\r\n\r\n        // Grab a reference to the potential matron\r\n        Kitty storage matron = kitties[_matronId];\r\n\r\n        // Make sure matron isn't pregnant, or in the middle of a siring cooldown\r\n        require(_isReadyToBreed(matron));\r\n\r\n        // Grab a reference to the potential sire\r\n        Kitty storage sire = kitties[_sireId];\r\n\r\n        // Make sure sire isn't pregnant, or in the middle of a siring cooldown\r\n        require(_isReadyToBreed(sire));\r\n\r\n        // Test that these cats are a valid mating pair.\r\n        require(_isValidMatingPair(\r\n            matron,\r\n            _matronId,\r\n            sire,\r\n            _sireId\r\n        ));\r\n\r\n        // All checks passed, kitty gets pregnant!\r\n        _breedWith(_matronId, _sireId);\r\n    }\r\n\r\n    /// @notice Have a pregnant Kitty give birth!\r\n    /// @param _matronId A Kitty ready to give birth.\r\n    /// @return The Kitty ID of the new kitten.\r\n    /// @dev Looks at a given Kitty and, if pregnant and if the gestation period has passed,\r\n    ///  combines the genes of the two parents to create a new kitten. The new Kitty is assigned\r\n    ///  to the current owner of the matron. Upon successful completion, both the matron and the\r\n    ///  new kitten will be ready to breed again. Note that anyone can call this function (if they\r\n    ///  are willing to pay the gas!), but the new kitten always goes to the mother's owner.\r\n    function giveBirth(uint256 _matronId)\r\n        external\r\n        whenNotPaused\r\n        returns(uint256)\r\n    {\r\n        // Grab a reference to the matron in storage.\r\n        Kitty storage matron = kitties[_matronId];\r\n\r\n        // Check that the matron is a valid cat.\r\n        require(matron.birthTime != 0);\r\n\r\n        // Check that the matron is pregnant, and that its time has come!\r\n        require(_isReadyToGiveBirth(matron));\r\n\r\n        // Grab a reference to the sire in storage.\r\n        uint256 sireId = matron.siringWithId;\r\n        Kitty storage sire = kitties[sireId];\r\n\r\n        // Determine the higher generation number of the two parents\r\n        uint16 parentGen = matron.generation;\r\n        if (sire.generation > matron.generation) {\r\n            parentGen = sire.generation;\r\n        }\r\n\r\n        // Call the sooper-sekret gene mixing operation.\r\n        uint256 childGenes = geneScience.mixGenes(matron.genes, sire.genes, matron.cooldownEndBlock - 1);\r\n\r\n        // Make the new kitten!\r\n        address owner = kittyIndexToOwner[_matronId];\r\n        uint256 kittenId = _createKitty(_matronId, matron.siringWithId, parentGen + 1, childGenes, owner);\r\n\r\n        // Clear the reference to sire from the matron (REQUIRED! Having siringWithId\r\n        // set is what marks a matron as being pregnant.)\r\n        delete matron.siringWithId;\r\n\r\n        // Every time a kitty gives birth counter is decremented.\r\n        pregnantKitties--;\r\n\r\n        // Send the balance fee to the person who made birth happen.\r\n        msg.sender.send(autoBirthFee);\r\n\r\n        // return the new kitten's ID\r\n        return kittenId;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Auction Core\r\n/// @dev Contains models, variables, and internal methods for the auction.\r\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\r\ncontract ClockAuctionBase {\r\n\r\n    // Represents an auction on an NFT\r\n    struct Auction {\r\n        // Current owner of NFT\r\n        address seller;\r\n        // Price (in wei) at beginning of auction\r\n        uint128 startingPrice;\r\n        // Price (in wei) at end of auction\r\n        uint128 endingPrice;\r\n        // Duration (in seconds) of auction\r\n        uint64 duration;\r\n        // Time when auction started\r\n        // NOTE: 0 if this auction has been concluded\r\n        uint64 startedAt;\r\n    }\r\n\r\n    // Reference to contract tracking NFT ownership\r\n    ERC721 public nonFungibleContract;\r\n\r\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\r\n    // Values 0-10,000 map to 0%-100%\r\n    uint256 public ownerCut;\r\n\r\n    // Map from token ID to their corresponding auction.\r\n    mapping (uint256 => Auction) tokenIdToAuction;\r\n\r\n    event AuctionCreated(uint256 tokenId, uint256 startingPrice, uint256 endingPrice, uint256 duration);\r\n    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address winner);\r\n    event AuctionCancelled(uint256 tokenId);\r\n\r\n    /// @dev Returns true if the claimant owns the token.\r\n    /// @param _claimant - Address claiming to own the token.\r\n    /// @param _tokenId - ID of token whose ownership to verify.\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\r\n    }\r\n\r\n    /// @dev Escrows the NFT, assigning ownership to this contract.\r\n    /// Throws if the escrow fails.\r\n    /// @param _owner - Current owner address of token to escrow.\r\n    /// @param _tokenId - ID of token whose approval to verify.\r\n    function _escrow(address _owner, uint256 _tokenId) internal {\r\n        // it will throw if transfer fails\r\n        nonFungibleContract.transferFrom(_owner, this, _tokenId);\r\n    }\r\n\r\n    /// @dev Transfers an NFT owned by this contract to another address.\r\n    /// Returns true if the transfer succeeds.\r\n    /// @param _receiver - Address to transfer NFT to.\r\n    /// @param _tokenId - ID of token to transfer.\r\n    function _transfer(address _receiver, uint256 _tokenId) internal {\r\n        // it will throw if transfer fails\r\n        nonFungibleContract.transfer(_receiver, _tokenId);\r\n    }\r\n\r\n    /// @dev Adds an auction to the list of open auctions. Also fires the\r\n    ///  AuctionCreated event.\r\n    /// @param _tokenId The ID of the token to be put on auction.\r\n    /// @param _auction Auction to add.\r\n    function _addAuction(uint256 _tokenId, Auction _auction) internal {\r\n        // Require that all auctions have a duration of\r\n        // at least one minute. (Keeps our math from getting hairy!)\r\n        require(_auction.duration >= 1 minutes);\r\n\r\n        tokenIdToAuction[_tokenId] = _auction;\r\n\r\n        AuctionCreated(\r\n            uint256(_tokenId),\r\n            uint256(_auction.startingPrice),\r\n            uint256(_auction.endingPrice),\r\n            uint256(_auction.duration)\r\n        );\r\n    }\r\n\r\n    /// @dev Cancels an auction unconditionally.\r\n    function _cancelAuction(uint256 _tokenId, address _seller) internal {\r\n        _removeAuction(_tokenId);\r\n        _transfer(_seller, _tokenId);\r\n        AuctionCancelled(_tokenId);\r\n    }\r\n\r\n    /// @dev Computes the price and transfers winnings.\r\n    /// Does NOT transfer ownership of token.\r\n    function _bid(uint256 _tokenId, uint256 _bidAmount)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        // Get a reference to the auction struct\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n\r\n        // Explicitly check that this auction is currently live.\r\n        // (Because of how Ethereum mappings work, we can't just count\r\n        // on the lookup above failing. An invalid _tokenId will just\r\n        // return an auction object that is all zeros.)\r\n        require(_isOnAuction(auction));\r\n\r\n        // Check that the bid is greater than or equal to the current price\r\n        uint256 price = _currentPrice(auction);\r\n        require(_bidAmount >= price);\r\n\r\n        // Grab a reference to the seller before the auction struct\r\n        // gets deleted.\r\n        address seller = auction.seller;\r\n\r\n        // The bid is good! Remove the auction before sending the fees\r\n        // to the sender so we can't have a reentrancy attack.\r\n        _removeAuction(_tokenId);\r\n\r\n        // Transfer proceeds to seller (if there are any!)\r\n        if (price > 0) {\r\n            // Calculate the auctioneer's cut.\r\n            // (NOTE: _computeCut() is guaranteed to return a\r\n            // value <= price, so this subtraction can't go negative.)\r\n            uint256 auctioneerCut = _computeCut(price);\r\n            uint256 sellerProceeds = price - auctioneerCut;\r\n\r\n            // NOTE: Doing a transfer() in the middle of a complex\r\n            // method like this is generally discouraged because of\r\n            // reentrancy attacks and DoS attacks if the seller is\r\n            // a contract with an invalid fallback function. We explicitly\r\n            // guard against reentrancy attacks by removing the auction\r\n            // before calling transfer(), and the only thing the seller\r\n            // can DoS is the sale of their own asset! (And if it's an\r\n            // accident, they can call cancelAuction(). )\r\n            seller.transfer(sellerProceeds);\r\n        }\r\n\r\n        // Calculate any excess funds included with the bid. If the excess\r\n        // is anything worth worrying about, transfer it back to bidder.\r\n        // NOTE: We checked above that the bid amount is greater than or\r\n        // equal to the price so this cannot underflow.\r\n        uint256 bidExcess = _bidAmount - price;\r\n\r\n        // Return the funds. Similar to the previous transfer, this is\r\n        // not susceptible to a re-entry attack because the auction is\r\n        // removed before any transfers occur.\r\n        msg.sender.transfer(bidExcess);\r\n\r\n        // Tell the world!\r\n        AuctionSuccessful(_tokenId, price, msg.sender);\r\n\r\n        return price;\r\n    }\r\n\r\n    /// @dev Removes an auction from the list of open auctions.\r\n    /// @param _tokenId - ID of NFT on auction.\r\n    function _removeAuction(uint256 _tokenId) internal {\r\n        delete tokenIdToAuction[_tokenId];\r\n    }\r\n\r\n    /// @dev Returns true if the NFT is on auction.\r\n    /// @param _auction - Auction to check.\r\n    function _isOnAuction(Auction storage _auction) internal view returns (bool) {\r\n        return (_auction.startedAt > 0);\r\n    }\r\n\r\n    /// @dev Returns current price of an NFT on auction. Broken into two\r\n    ///  functions (this one, that computes the duration from the auction\r\n    ///  structure, and the other that does the price computation) so we\r\n    ///  can easily test that the price computation works correctly.\r\n    function _currentPrice(Auction storage _auction)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 secondsPassed = 0;\r\n\r\n        // A bit of insurance against negative values (or wraparound).\r\n        // Probably not necessary (since Ethereum guarnatees that the\r\n        // now variable doesn't ever go backwards).\r\n        if (now > _auction.startedAt) {\r\n            secondsPassed = now - _auction.startedAt;\r\n        }\r\n\r\n        return _computeCurrentPrice(\r\n            _auction.startingPrice,\r\n            _auction.endingPrice,\r\n            _auction.duration,\r\n            secondsPassed\r\n        );\r\n    }\r\n\r\n    /// @dev Computes the current price of an auction. Factored out\r\n    ///  from _currentPrice so we can run extensive unit tests.\r\n    ///  When testing, make this function public and turn on\r\n    ///  `Current price computation` test suite.\r\n    function _computeCurrentPrice(\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        uint256 _secondsPassed\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        //  all of our public functions carefully cap the maximum values for\r\n        //  time (at 64-bits) and currency (at 128-bits). _duration is\r\n        //  also known to be non-zero (see the require() statement in\r\n        //  _addAuction())\r\n        if (_secondsPassed >= _duration) {\r\n            // We've reached the end of the dynamic pricing portion\r\n            // of the auction, just return the end price.\r\n            return _endingPrice;\r\n        } else {\r\n            // Starting price can be higher than ending price (and often is!), so\r\n            // this delta can be negative.\r\n            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\r\n\r\n            // This multiplication can't overflow, _secondsPassed will easily fit within\r\n            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\r\n            // will always fit within 256-bits.\r\n            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\r\n\r\n            // currentPriceChange can be negative, but if so, will have a magnitude\r\n            // less that _startingPrice. Thus, this result will always end up positive.\r\n            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\r\n\r\n            return uint256(currentPrice);\r\n        }\r\n    }\r\n\r\n    /// @dev Computes owner's cut of a sale.\r\n    /// @param _price - Sale price of NFT.\r\n    function _computeCut(uint256 _price) internal view returns (uint256) {\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        //  all of our entry functions carefully cap the maximum values for\r\n        //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\r\n        //  statement in the ClockAuction constructor). The result of this\r\n        //  function is always guaranteed to be <= _price.\r\n        return _price * ownerCut / 10000;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS paused\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\n   */\r\n  modifier whenPaused {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused returns (bool) {\r\n    paused = true;\r\n    Pause();\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused returns (bool) {\r\n    paused = false;\r\n    Unpause();\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\n/// @title Clock auction for non-fungible tokens.\r\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\r\ncontract ClockAuction is Pausable, ClockAuctionBase {\r\n\r\n    /// @dev The ERC-165 interface signature for ERC-721.\r\n    ///  Ref: https://github.com/ethereum/EIPs/issues/165\r\n    ///  Ref: https://github.com/ethereum/EIPs/issues/721\r\n    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);\r\n\r\n    /// @dev Constructor creates a reference to the NFT ownership contract\r\n    ///  and verifies the owner cut is in the valid range.\r\n    /// @param _nftAddress - address of a deployed contract implementing\r\n    ///  the Nonfungible Interface.\r\n    /// @param _cut - percent cut the owner takes on each auction, must be\r\n    ///  between 0-10,000.\r\n    function ClockAuction(address _nftAddress, uint256 _cut) public {\r\n        require(_cut <= 10000);\r\n        ownerCut = _cut;\r\n\r\n        ERC721 candidateContract = ERC721(_nftAddress);\r\n        require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\r\n        nonFungibleContract = candidateContract;\r\n    }\r\n\r\n    /// @dev Remove all Ether from the contract, which is the owner's cuts\r\n    ///  as well as any Ether sent directly to the contract address.\r\n    ///  Always transfers to the NFT contract, but can be called either by\r\n    ///  the owner or the NFT contract.\r\n    function withdrawBalance() external {\r\n        address nftAddress = address(nonFungibleContract);\r\n\r\n        require(\r\n            msg.sender == owner ||\r\n            msg.sender == nftAddress\r\n        );\r\n        // We are using this boolean method to make sure that even if one fails it will still work\r\n        bool res = nftAddress.send(this.balance);\r\n    }\r\n\r\n    /// @dev Creates and begins a new auction.\r\n    /// @param _tokenId - ID of token to auction, sender must be owner.\r\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\r\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\r\n    /// @param _duration - Length of time to move between starting\r\n    ///  price and ending price (in seconds).\r\n    /// @param _seller - Seller, if not the message sender\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _seller\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        // Sanity check that no inputs overflow how many bits we've allocated\r\n        // to store them in the auction struct.\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        require(_duration == uint256(uint64(_duration)));\r\n\r\n        require(_owns(msg.sender, _tokenId));\r\n        _escrow(msg.sender, _tokenId);\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now)\r\n        );\r\n        _addAuction(_tokenId, auction);\r\n    }\r\n\r\n    /// @dev Bids on an open auction, completing the auction and transferring\r\n    ///  ownership of the NFT if enough Ether is supplied.\r\n    /// @param _tokenId - ID of token to bid on.\r\n    function bid(uint256 _tokenId)\r\n        external\r\n        payable\r\n        whenNotPaused\r\n    {\r\n        // _bid will throw if the bid or funds transfer fails\r\n        _bid(_tokenId, msg.value);\r\n        _transfer(msg.sender, _tokenId);\r\n    }\r\n\r\n    /// @dev Cancels an auction that hasn't been won yet.\r\n    ///  Returns the NFT to original owner.\r\n    /// @notice This is a state-modifying function that can\r\n    ///  be called while the contract is paused.\r\n    /// @param _tokenId - ID of token on auction\r\n    function cancelAuction(uint256 _tokenId)\r\n        external\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        address seller = auction.seller;\r\n        require(msg.sender == seller);\r\n        _cancelAuction(_tokenId, seller);\r\n    }\r\n\r\n    /// @dev Cancels an auction when the contract is paused.\r\n    ///  Only the owner may do this, and NFTs are returned to\r\n    ///  the seller. This should only be used in emergencies.\r\n    /// @param _tokenId - ID of the NFT on auction to cancel.\r\n    function cancelAuctionWhenPaused(uint256 _tokenId)\r\n        whenPaused\r\n        onlyOwner\r\n        external\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        _cancelAuction(_tokenId, auction.seller);\r\n    }\r\n\r\n    /// @dev Returns auction info for an NFT on auction.\r\n    /// @param _tokenId - ID of NFT on auction.\r\n    function getAuction(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns\r\n    (\r\n        address seller,\r\n        uint256 startingPrice,\r\n        uint256 endingPrice,\r\n        uint256 duration,\r\n        uint256 startedAt\r\n    ) {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        return (\r\n            auction.seller,\r\n            auction.startingPrice,\r\n            auction.endingPrice,\r\n            auction.duration,\r\n            auction.startedAt\r\n        );\r\n    }\r\n\r\n    /// @dev Returns the current price of an auction.\r\n    /// @param _tokenId - ID of the token price we are checking.\r\n    function getCurrentPrice(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        return _currentPrice(auction);\r\n    }\r\n\r\n}\r\n\r\n\r\n/// @title Reverse auction modified for siring\r\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\r\ncontract SiringClockAuction is ClockAuction {\r\n\r\n    // @dev Sanity check that allows us to ensure that we are pointing to the\r\n    //  right auction in our setSiringAuctionAddress() call.\r\n    bool public isSiringClockAuction = true;\r\n\r\n    // Delegate constructor\r\n    function SiringClockAuction(address _nftAddr, uint256 _cut) public\r\n        ClockAuction(_nftAddr, _cut) {}\r\n\r\n    /// @dev Creates and begins a new auction. Since this function is wrapped,\r\n    /// require sender to be KittyCore contract.\r\n    /// @param _tokenId - ID of token to auction, sender must be owner.\r\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\r\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\r\n    /// @param _duration - Length of auction (in seconds).\r\n    /// @param _seller - Seller, if not the message sender\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _seller\r\n    )\r\n        external\r\n    {\r\n        // Sanity check that no inputs overflow how many bits we've allocated\r\n        // to store them in the auction struct.\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        require(_duration == uint256(uint64(_duration)));\r\n\r\n        require(msg.sender == address(nonFungibleContract));\r\n        _escrow(_seller, _tokenId);\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now)\r\n        );\r\n        _addAuction(_tokenId, auction);\r\n    }\r\n\r\n    /// @dev Places a bid for siring. Requires the sender\r\n    /// is the KittyCore contract because all bid methods\r\n    /// should be wrapped. Also returns the kitty to the\r\n    /// seller rather than the winner.\r\n    function bid(uint256 _tokenId)\r\n        external\r\n        payable\r\n    {\r\n        require(msg.sender == address(nonFungibleContract));\r\n        address seller = tokenIdToAuction[_tokenId].seller;\r\n        // _bid checks that token ID is valid and will throw if bid fails\r\n        _bid(_tokenId, msg.value);\r\n        // We transfer the kitty back to the seller, the winner will get\r\n        // the offspring\r\n        _transfer(seller, _tokenId);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @title Clock auction modified for sale of kitties\r\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\r\ncontract SaleClockAuction is ClockAuction {\r\n\r\n    // @dev Sanity check that allows us to ensure that we are pointing to the\r\n    //  right auction in our setSaleAuctionAddress() call.\r\n    bool public isSaleClockAuction = true;\r\n\r\n    // Tracks last 5 sale price of gen0 kitty sales\r\n    uint256 public gen0SaleCount;\r\n    uint256[5] public lastGen0SalePrices;\r\n\r\n    // Delegate constructor\r\n    function SaleClockAuction(address _nftAddr, uint256 _cut) public\r\n        ClockAuction(_nftAddr, _cut) {}\r\n\r\n    /// @dev Creates and begins a new auction.\r\n    /// @param _tokenId - ID of token to auction, sender must be owner.\r\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\r\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\r\n    /// @param _duration - Length of auction (in seconds).\r\n    /// @param _seller - Seller, if not the message sender\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _seller\r\n    )\r\n        external\r\n    {\r\n        // Sanity check that no inputs overflow how many bits we've allocated\r\n        // to store them in the auction struct.\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        require(_duration == uint256(uint64(_duration)));\r\n\r\n        require(msg.sender == address(nonFungibleContract));\r\n        _escrow(_seller, _tokenId);\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now)\r\n        );\r\n        _addAuction(_tokenId, auction);\r\n    }\r\n\r\n    /// @dev Updates lastSalePrice if seller is the nft contract\r\n    /// Otherwise, works the same as default bid method.\r\n    function bid(uint256 _tokenId)\r\n        external\r\n        payable\r\n    {\r\n        // _bid verifies token ID size\r\n        address seller = tokenIdToAuction[_tokenId].seller;\r\n        uint256 price = _bid(_tokenId, msg.value);\r\n        _transfer(msg.sender, _tokenId);\r\n\r\n        // If not a gen0 auction, exit\r\n        if (seller == address(nonFungibleContract)) {\r\n            // Track gen0 sale prices\r\n            lastGen0SalePrices[gen0SaleCount % 5] = price;\r\n            gen0SaleCount++;\r\n        }\r\n    }\r\n\r\n    function averageGen0SalePrice() external view returns (uint256) {\r\n        uint256 sum = 0;\r\n        for (uint256 i = 0; i < 5; i++) {\r\n            sum += lastGen0SalePrices[i];\r\n        }\r\n        return sum / 5;\r\n    }\r\n\r\n}\r\n\r\n\r\n/// @title Handles creating auctions for sale and siring of kitties.\r\n///  This wrapper of ReverseAuction exists only so that users can create\r\n///  auctions with only one transaction.\r\ncontract KittyAuction is KittyBreeding {\r\n\r\n    // @notice The auction contract variables are defined in KittyBase to allow\r\n    //  us to refer to them in KittyOwnership to prevent accidental transfers.\r\n    // `saleAuction` refers to the auction for gen0 and p2p sale of kitties.\r\n    // `siringAuction` refers to the auction for siring rights of kitties.\r\n\r\n    /// @dev Sets the reference to the sale auction.\r\n    /// @param _address - Address of sale contract.\r\n    function setSaleAuctionAddress(address _address) external onlyCEO {\r\n        SaleClockAuction candidateContract = SaleClockAuction(_address);\r\n\r\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\r\n        require(candidateContract.isSaleClockAuction());\r\n\r\n        // Set the new contract address\r\n        saleAuction = candidateContract;\r\n    }\r\n\r\n    /// @dev Sets the reference to the siring auction.\r\n    /// @param _address - Address of siring contract.\r\n    function setSiringAuctionAddress(address _address) external onlyCEO {\r\n        SiringClockAuction candidateContract = SiringClockAuction(_address);\r\n\r\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\r\n        require(candidateContract.isSiringClockAuction());\r\n\r\n        // Set the new contract address\r\n        siringAuction = candidateContract;\r\n    }\r\n\r\n    /// @dev Put a kitty up for auction.\r\n    ///  Does some ownership trickery to create auctions in one tx.\r\n    function createSaleAuction(\r\n        uint256 _kittyId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        // Auction contract checks input sizes\r\n        // If kitty is already on any auction, this will throw\r\n        // because it will be owned by the auction contract.\r\n        require(_owns(msg.sender, _kittyId));\r\n        // Ensure the kitty is not pregnant to prevent the auction\r\n        // contract accidentally receiving ownership of the child.\r\n        // NOTE: the kitty IS allowed to be in a cooldown.\r\n        require(!isPregnant(_kittyId));\r\n        _approve(_kittyId, saleAuction);\r\n        // Sale auction throws if inputs are invalid and clears\r\n        // transfer and sire approval after escrowing the kitty.\r\n        saleAuction.createAuction(\r\n            _kittyId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /// @dev Put a kitty up for auction to be sire.\r\n    ///  Performs checks to ensure the kitty can be sired, then\r\n    ///  delegates to reverse auction.\r\n    function createSiringAuction(\r\n        uint256 _kittyId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        // Auction contract checks input sizes\r\n        // If kitty is already on any auction, this will throw\r\n        // because it will be owned by the auction contract.\r\n        require(_owns(msg.sender, _kittyId));\r\n        require(isReadyToBreed(_kittyId));\r\n        _approve(_kittyId, siringAuction);\r\n        // Siring auction throws if inputs are invalid and clears\r\n        // transfer and sire approval after escrowing the kitty.\r\n        siringAuction.createAuction(\r\n            _kittyId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /// @dev Completes a siring auction by bidding.\r\n    ///  Immediately breeds the winning matron with the sire on auction.\r\n    /// @param _sireId - ID of the sire on auction.\r\n    /// @param _matronId - ID of the matron owned by the bidder.\r\n    function bidOnSiringAuction(\r\n        uint256 _sireId,\r\n        uint256 _matronId\r\n    )\r\n        external\r\n        payable\r\n        whenNotPaused\r\n    {\r\n        // Auction contract checks input sizes\r\n        require(_owns(msg.sender, _matronId));\r\n        require(isReadyToBreed(_matronId));\r\n        require(_canBreedWithViaAuction(_matronId, _sireId));\r\n\r\n        // Define the current price of the auction.\r\n        uint256 currentPrice = siringAuction.getCurrentPrice(_sireId);\r\n        require(msg.value >= currentPrice + autoBirthFee);\r\n\r\n        // Siring auction will throw if the bid fails.\r\n        siringAuction.bid.value(msg.value - autoBirthFee)(_sireId);\r\n        _breedWith(uint32(_matronId), uint32(_sireId));\r\n    }\r\n\r\n    /// @dev Transfers the balance of the sale auction contract\r\n    /// to the KittyCore contract. We use two-step withdrawal to\r\n    /// prevent two transfer calls in the auction bid function.\r\n    function withdrawAuctionBalances() external onlyCLevel {\r\n        saleAuction.withdrawBalance();\r\n        siringAuction.withdrawBalance();\r\n    }\r\n}\r\n\r\n\r\n/// @title all functions related to creating kittens\r\ncontract KittyMinting is KittyAuction {\r\n\r\n    // Limits the number of cats the contract owner can ever create.\r\n    uint256 public constant PROMO_CREATION_LIMIT = 5000;\r\n    uint256 public constant GEN0_CREATION_LIMIT = 45000;\r\n\r\n    // Constants for gen0 auctions.\r\n    uint256 public constant GEN0_STARTING_PRICE = 10 finney;\r\n    uint256 public constant GEN0_AUCTION_DURATION = 1 days;\r\n\r\n    // Counts the number of cats the contract owner has created.\r\n    uint256 public promoCreatedCount;\r\n    uint256 public gen0CreatedCount;\r\n\r\n    /// @dev we can create promo kittens, up to a limit. Only callable by COO\r\n    /// @param _genes the encoded genes of the kitten to be created, any value is accepted\r\n    /// @param _owner the future owner of the created kittens. Default to contract COO\r\n    function createPromoKitty(uint256 _genes, address _owner) external onlyCOO {\r\n        address kittyOwner = _owner;\r\n        if (kittyOwner == address(0)) {\r\n             kittyOwner = cooAddress;\r\n        }\r\n        require(promoCreatedCount < PROMO_CREATION_LIMIT);\r\n\r\n        promoCreatedCount++;\r\n        _createKitty(0, 0, 0, _genes, kittyOwner);\r\n    }\r\n\r\n    /// @dev Creates a new gen0 kitty with the given genes and\r\n    ///  creates an auction for it.\r\n    function createGen0Auction(uint256 _genes) external onlyCOO {\r\n        require(gen0CreatedCount < GEN0_CREATION_LIMIT);\r\n\r\n        uint256 kittyId = _createKitty(0, 0, 0, _genes, address(this));\r\n        _approve(kittyId, saleAuction);\r\n\r\n        saleAuction.createAuction(\r\n            kittyId,\r\n            _computeNextGen0Price(),\r\n            0,\r\n            GEN0_AUCTION_DURATION,\r\n            address(this)\r\n        );\r\n\r\n        gen0CreatedCount++;\r\n    }\r\n\r\n    /// @dev Computes the next gen0 auction starting price, given\r\n    ///  the average of the past 5 prices + 50%.\r\n    function _computeNextGen0Price() internal view returns (uint256) {\r\n        uint256 avePrice = saleAuction.averageGen0SalePrice();\r\n\r\n        // Sanity check to ensure we don't overflow arithmetic\r\n        require(avePrice == uint256(uint128(avePrice)));\r\n\r\n        uint256 nextPrice = avePrice + (avePrice / 2);\r\n\r\n        // We never auction for less than starting price\r\n        if (nextPrice < GEN0_STARTING_PRICE) {\r\n            nextPrice = GEN0_STARTING_PRICE;\r\n        }\r\n\r\n        return nextPrice;\r\n    }\r\n}\r\n\r\n\r\n/// @title CryptoKitties: Collectible, breedable, and oh-so-adorable cats on the Ethereum blockchain.\r\n/// @author Axiom Zen (https://www.axiomzen.co)\r\n/// @dev The main CryptoKitties contract, keeps track of kittens so they don't wander around and get lost.\r\ncontract KittyCore is KittyMinting {\r\n\r\n    // This is the main CryptoKitties contract. In order to keep our code seperated into logical sections,\r\n    // we've broken it up in two ways. First, we have several seperately-instantiated sibling contracts\r\n    // that handle auctions and our super-top-secret genetic combination algorithm. The auctions are\r\n    // seperate since their logic is somewhat complex and there's always a risk of subtle bugs. By keeping\r\n    // them in their own contracts, we can upgrade them without disrupting the main contract that tracks\r\n    // kitty ownership. The genetic combination algorithm is kept seperate so we can open-source all of\r\n    // the rest of our code without making it _too_ easy for folks to figure out how the genetics work.\r\n    // Don't worry, I'm sure someone will reverse engineer it soon enough!\r\n    //\r\n    // Secondly, we break the core contract into multiple files using inheritence, one for each major\r\n    // facet of functionality of CK. This allows us to keep related code bundled together while still\r\n    // avoiding a single giant file with everything in it. The breakdown is as follows:\r\n    //\r\n    //      - KittyBase: This is where we define the most fundamental code shared throughout the core\r\n    //             functionality. This includes our main data storage, constants and data types, plus\r\n    //             internal functions for managing these items.\r\n    //\r\n    //      - KittyAccessControl: This contract manages the various addresses and constraints for operations\r\n    //             that can be executed only by specific roles. Namely CEO, CFO and COO.\r\n    //\r\n    //      - KittyOwnership: This provides the methods required for basic non-fungible token\r\n    //             transactions, following the draft ERC-721 spec (https://github.com/ethereum/EIPs/issues/721).\r\n    //\r\n    //      - KittyBreeding: This file contains the methods necessary to breed cats together, including\r\n    //             keeping track of siring offers, and relies on an external genetic combination contract.\r\n    //\r\n    //      - KittyAuctions: Here we have the public methods for auctioning or bidding on cats or siring\r\n    //             services. The actual auction functionality is handled in two sibling contracts (one\r\n    //             for sales and one for siring), while auction creation and bidding is mostly mediated\r\n    //             through this facet of the core contract.\r\n    //\r\n    //      - KittyMinting: This final facet contains the functionality we use for creating new gen0 cats.\r\n    //             We can make up to 5000 \"promo\" cats that can be given away (especially important when\r\n    //             the community is new), and all others can only be created and then immediately put up\r\n    //             for auction via an algorithmically determined starting price. Regardless of how they\r\n    //             are created, there is a hard limit of 50k gen0 cats. After that, it's all up to the\r\n    //             community to breed, breed, breed!\r\n\r\n    // Set in case the core contract is broken and an upgrade is required\r\n    address public newContractAddress;\r\n\r\n    /// @notice Creates the main CryptoKitties smart contract instance.\r\n    function KittyCore() public {\r\n        // Starts paused.\r\n        paused = true;\r\n\r\n        // the creator of the contract is the initial CEO\r\n        ceoAddress = msg.sender;\r\n\r\n        // the creator of the contract is also the initial COO\r\n        cooAddress = msg.sender;\r\n\r\n        // start with the mythical kitten 0 - so we don't have generation-0 parent issues\r\n        _createKitty(0, 0, 0, uint256(-1), address(0));\r\n    }\r\n\r\n    /// @dev Used to mark the smart contract as upgraded, in case there is a serious\r\n    ///  breaking bug. This method does nothing but keep track of the new contract and\r\n    ///  emit a message indicating that the new address is set. It's up to clients of this\r\n    ///  contract to update to the new contract address in that case. (This contract will\r\n    ///  be paused indefinitely if such an upgrade takes place.)\r\n    /// @param _v2Address new address\r\n    function setNewAddress(address _v2Address) external onlyCEO whenPaused {\r\n        // See README.md for updgrade plan\r\n        newContractAddress = _v2Address;\r\n        ContractUpgrade(_v2Address);\r\n    }\r\n\r\n    /// @notice No tipping!\r\n    /// @dev Reject all Ether from being sent here, unless it's from one of the\r\n    ///  two auction contracts. (Hopefully, we can prevent user accidents.)\r\n    function() external payable {\r\n        require(\r\n            msg.sender == address(saleAuction) ||\r\n            msg.sender == address(siringAuction)\r\n        );\r\n    }\r\n\r\n    /// @notice Returns all the relevant information about a specific kitty.\r\n    /// @param _id The ID of the kitty of interest.\r\n    function getKitty(uint256 _id)\r\n        external\r\n        view\r\n        returns (\r\n        bool isGestating,\r\n        bool isReady,\r\n        uint256 cooldownIndex,\r\n        uint256 nextActionAt,\r\n        uint256 siringWithId,\r\n        uint256 birthTime,\r\n        uint256 matronId,\r\n        uint256 sireId,\r\n        uint256 generation,\r\n        uint256 genes\r\n    ) {\r\n        Kitty storage kit = kitties[_id];\r\n\r\n        // if this variable is 0 then it's not gestating\r\n        isGestating = (kit.siringWithId != 0);\r\n        isReady = (kit.cooldownEndBlock <= block.number);\r\n        cooldownIndex = uint256(kit.cooldownIndex);\r\n        nextActionAt = uint256(kit.cooldownEndBlock);\r\n        siringWithId = uint256(kit.siringWithId);\r\n        birthTime = uint256(kit.birthTime);\r\n        matronId = uint256(kit.matronId);\r\n        sireId = uint256(kit.sireId);\r\n        generation = uint256(kit.generation);\r\n        genes = kit.genes;\r\n    }\r\n\r\n    /// @dev Override unpause so it requires all external contract addresses\r\n    ///  to be set before contract can be unpaused. Also, we can't have\r\n    ///  newContractAddress set either, because then the contract was upgraded.\r\n    /// @notice This is public rather than external so we can call super.unpause\r\n    ///  without using an expensive CALL.\r\n    function unpause() public onlyCEO whenPaused {\r\n        require(saleAuction != address(0));\r\n        require(siringAuction != address(0));\r\n        require(geneScience != address(0));\r\n        require(newContractAddress == address(0));\r\n\r\n        // Actually unpause the contract.\r\n        super.unpause();\r\n    }\r\n\r\n    // @dev Allows the CFO to capture the balance available to the contract.\r\n    function withdrawBalance() external onlyCFO {\r\n        uint256 balance = this.balance;\r\n        // Subtract all the currently pregnant kittens we have, plus 1 of margin.\r\n        uint256 subtractFees = (pregnantKitties + 1) * autoBirthFee;\r\n\r\n        if (balance > subtractFees) {\r\n            cfoAddress.send(balance - subtractFees);\r\n        }\r\n    }\r\n}",
		"ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_preferredTransport\",\"type\":\"string\"}],\"name\":\"tokenMetadata\",\"outputs\":[{\"name\":\"infoUrl\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"promoCreatedCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GEN0_STARTING_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setSiringAuctionAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pregnantKitties\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_kittyId\",\"type\":\"uint256\"}],\"name\":\"isPregnant\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GEN0_AUCTION_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"siringAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setGeneScienceAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kittyId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"createSaleAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sireAllowedToAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_matronId\",\"type\":\"uint256\"},{\"name\":\"_sireId\",\"type\":\"uint256\"}],\"name\":\"canBreedWith\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"kittyIndexToApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kittyId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"createSiringAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"setAutoBirthFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_sireId\",\"type\":\"uint256\"}],\"name\":\"approveSiring\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_genes\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"createPromoKitty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"secs\",\"type\":\"uint256\"}],\"name\":\"setSecondsPerBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GEN0_CREATION_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setSaleAuctionAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_v2Address\",\"type\":\"address\"}],\"name\":\"setNewAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondsPerBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"ownerTokens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_matronId\",\"type\":\"uint256\"}],\"name\":\"giveBirth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAuctionBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cooldowns\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"kittyIndexToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"autoBirthFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc721Metadata\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_genes\",\"type\":\"uint256\"}],\"name\":\"createGen0Auction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_kittyId\",\"type\":\"uint256\"}],\"name\":\"isReadyToBreed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROMO_CREATION_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"setMetadataAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getKitty\",\"outputs\":[{\"name\":\"isGestating\",\"type\":\"bool\"},{\"name\":\"isReady\",\"type\":\"bool\"},{\"name\":\"cooldownIndex\",\"type\":\"uint256\"},{\"name\":\"nextActionAt\",\"type\":\"uint256\"},{\"name\":\"siringWithId\",\"type\":\"uint256\"},{\"name\":\"birthTime\",\"type\":\"uint256\"},{\"name\":\"matronId\",\"type\":\"uint256\"},{\"name\":\"sireId\",\"type\":\"uint256\"},{\"name\":\"generation\",\"type\":\"uint256\"},{\"name\":\"genes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sireId\",\"type\":\"uint256\"},{\"name\":\"_matronId\",\"type\":\"uint256\"}],\"name\":\"bidOnSiringAuction\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gen0CreatedCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"geneScience\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_matronId\",\"type\":\"uint256\"},{\"name\":\"_sireId\",\"type\":\"uint256\"}],\"name\":\"breedWithAuto\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"matronId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sireId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cooldownEndBlock\",\"type\":\"uint256\"}],\"name\":\"Pregnant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"kittyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"matronId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sireId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genes\",\"type\":\"uint256\"}],\"name\":\"Birth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"}]",
		"ContractName": "KittyCore",
		"Address": "0x06012c8cf97bead5deae237070f9587f8e7a266d",
		"CompilerVersion": "v0.4.18+commit.9cf6e910",
		"OptimizationUsed": "1",
		"Runs": "200",
		"ConstructorArguments": "",
		"Library": "",
		"SwarmSource": "bzzr://a6465fc1ce7ab1a92906ff7206b23d80a21bbd50b85b4bde6a91f8e6b2e3edde"
	},
	{
		"SourceCode": "// Copyright (C) 2015, 2016, 2017 Dapphub\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.4.18;\r\n\r\ncontract WETH9 {\r\n    string public name     = \"Wrapped Ether\";\r\n    string public symbol   = \"WETH\";\r\n    uint8  public decimals = 18;\r\n\r\n    event  Approval(address indexed src, address indexed guy, uint wad);\r\n    event  Transfer(address indexed src, address indexed dst, uint wad);\r\n    event  Deposit(address indexed dst, uint wad);\r\n    event  Withdrawal(address indexed src, uint wad);\r\n\r\n    mapping (address => uint)                       public  balanceOf;\r\n    mapping (address => mapping (address => uint))  public  allowance;\r\n\r\n    function() public payable {\r\n        deposit();\r\n    }\r\n    function deposit() public payable {\r\n        balanceOf[msg.sender] += msg.value;\r\n        Deposit(msg.sender, msg.value);\r\n    }\r\n    function withdraw(uint wad) public {\r\n        require(balanceOf[msg.sender] >= wad);\r\n        balanceOf[msg.sender] -= wad;\r\n        msg.sender.transfer(wad);\r\n        Withdrawal(msg.sender, wad);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return this.balance;\r\n    }\r\n\r\n    function approve(address guy, uint wad) public returns (bool) {\r\n        allowance[msg.sender][guy] = wad;\r\n        Approval(msg.sender, guy, wad);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint wad) public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(balanceOf[src] >= wad);\r\n\r\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n            require(allowance[src][msg.sender] >= wad);\r\n            allowance[src][msg.sender] -= wad;\r\n        }\r\n\r\n        balanceOf[src] -= wad;\r\n        balanceOf[dst] += wad;\r\n\r\n        Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n                    GNU GENERAL PUBLIC LICENSE\r\n                       Version 3, 29 June 2007\r\n\r\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\r\n Everyone is permitted to copy and distribute verbatim copies\r\n of this license document, but changing it is not allowed.\r\n\r\n                            Preamble\r\n\r\n  The GNU General Public License is a free, copyleft license for\r\nsoftware and other kinds of works.\r\n\r\n  The licenses for most software and other practical works are designed\r\nto take away your freedom to share and change the works.  By contrast,\r\nthe GNU General Public License is intended to guarantee your freedom to\r\nshare and change all versions of a program--to make sure it remains free\r\nsoftware for all its users.  We, the Free Software Foundation, use the\r\nGNU General Public License for most of our software; it applies also to\r\nany other work released this way by its authors.  You can apply it to\r\nyour programs, too.\r\n\r\n  When we speak of free software, we are referring to freedom, not\r\nprice.  Our General Public Licenses are designed to make sure that you\r\nhave the freedom to distribute copies of free software (and charge for\r\nthem if you wish), that you receive source code or can get it if you\r\nwant it, that you can change the software or use pieces of it in new\r\nfree programs, and that you know you can do these things.\r\n\r\n  To protect your rights, we need to prevent others from denying you\r\nthese rights or asking you to surrender the rights.  Therefore, you have\r\ncertain responsibilities if you distribute copies of the software, or if\r\nyou modify it: responsibilities to respect the freedom of others.\r\n\r\n  For example, if you distribute copies of such a program, whether\r\ngratis or for a fee, you must pass on to the recipients the same\r\nfreedoms that you received.  You must make sure that they, too, receive\r\nor can get the source code.  And you must show them these terms so they\r\nknow their rights.\r\n\r\n  Developers that use the GNU GPL protect your rights with two steps:\r\n(1) assert copyright on the software, and (2) offer you this License\r\ngiving you legal permission to copy, distribute and/or modify it.\r\n\r\n  For the developers' and authors' protection, the GPL clearly explains\r\nthat there is no warranty for this free software.  For both users' and\r\nauthors' sake, the GPL requires that modified versions be marked as\r\nchanged, so that their problems will not be attributed erroneously to\r\nauthors of previous versions.\r\n\r\n  Some devices are designed to deny users access to install or run\r\nmodified versions of the software inside them, although the manufacturer\r\ncan do so.  This is fundamentally incompatible with the aim of\r\nprotecting users' freedom to change the software.  The systematic\r\npattern of such abuse occurs in the area of products for individuals to\r\nuse, which is precisely where it is most unacceptable.  Therefore, we\r\nhave designed this version of the GPL to prohibit the practice for those\r\nproducts.  If such problems arise substantially in other domains, we\r\nstand ready to extend this provision to those domains in future versions\r\nof the GPL, as needed to protect the freedom of users.\r\n\r\n  Finally, every program is threatened constantly by software patents.\r\nStates should not allow patents to restrict development and use of\r\nsoftware on general-purpose computers, but in those that do, we wish to\r\navoid the special danger that patents applied to a free program could\r\nmake it effectively proprietary.  To prevent this, the GPL assures that\r\npatents cannot be used to render the program non-free.\r\n\r\n  The precise terms and conditions for copying, distribution and\r\nmodification follow.\r\n\r\n                       TERMS AND CONDITIONS\r\n\r\n  0. Definitions.\r\n\r\n  \"This License\" refers to version 3 of the GNU General Public License.\r\n\r\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\r\nworks, such as semiconductor masks.\r\n\r\n  \"The Program\" refers to any copyrightable work licensed under this\r\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\r\n\"recipients\" may be individuals or organizations.\r\n\r\n  To \"modify\" a work means to copy from or adapt all or part of the work\r\nin a fashion requiring copyright permission, other than the making of an\r\nexact copy.  The resulting work is called a \"modified version\" of the\r\nearlier work or a work \"based on\" the earlier work.\r\n\r\n  A \"covered work\" means either the unmodified Program or a work based\r\non the Program.\r\n\r\n  To \"propagate\" a work means to do anything with it that, without\r\npermission, would make you directly or secondarily liable for\r\ninfringement under applicable copyright law, except executing it on a\r\ncomputer or modifying a private copy.  Propagation includes copying,\r\ndistribution (with or without modification), making available to the\r\npublic, and in some countries other activities as well.\r\n\r\n  To \"convey\" a work means any kind of propagation that enables other\r\nparties to make or receive copies.  Mere interaction with a user through\r\na computer network, with no transfer of a copy, is not conveying.\r\n\r\n  An interactive user interface displays \"Appropriate Legal Notices\"\r\nto the extent that it includes a convenient and prominently visible\r\nfeature that (1) displays an appropriate copyright notice, and (2)\r\ntells the user that there is no warranty for the work (except to the\r\nextent that warranties are provided), that licensees may convey the\r\nwork under this License, and how to view a copy of this License.  If\r\nthe interface presents a list of user commands or options, such as a\r\nmenu, a prominent item in the list meets this criterion.\r\n\r\n  1. Source Code.\r\n\r\n  The \"source code\" for a work means the preferred form of the work\r\nfor making modifications to it.  \"Object code\" means any non-source\r\nform of a work.\r\n\r\n  A \"Standard Interface\" means an interface that either is an official\r\nstandard defined by a recognized standards body, or, in the case of\r\ninterfaces specified for a particular programming language, one that\r\nis widely used among developers working in that language.\r\n\r\n  The \"System Libraries\" of an executable work include anything, other\r\nthan the work as a whole, that (a) is included in the normal form of\r\npackaging a Major Component, but which is not part of that Major\r\nComponent, and (b) serves only to enable use of the work with that\r\nMajor Component, or to implement a Standard Interface for which an\r\nimplementation is available to the public in source code form.  A\r\n\"Major Component\", in this context, means a major essential component\r\n(kernel, window system, and so on) of the specific operating system\r\n(if any) on which the executable work runs, or a compiler used to\r\nproduce the work, or an object code interpreter used to run it.\r\n\r\n  The \"Corresponding Source\" for a work in object code form means all\r\nthe source code needed to generate, install, and (for an executable\r\nwork) run the object code and to modify the work, including scripts to\r\ncontrol those activities.  However, it does not include the work's\r\nSystem Libraries, or general-purpose tools or generally available free\r\nprograms which are used unmodified in performing those activities but\r\nwhich are not part of the work.  For example, Corresponding Source\r\nincludes interface definition files associated with source files for\r\nthe work, and the source code for shared libraries and dynamically\r\nlinked subprograms that the work is specifically designed to require,\r\nsuch as by intimate data communication or control flow between those\r\nsubprograms and other parts of the work.\r\n\r\n  The Corresponding Source need not include anything that users\r\ncan regenerate automatically from other parts of the Corresponding\r\nSource.\r\n\r\n  The Corresponding Source for a work in source code form is that\r\nsame work.\r\n\r\n  2. Basic Permissions.\r\n\r\n  All rights granted under this License are granted for the term of\r\ncopyright on the Program, and are irrevocable provided the stated\r\nconditions are met.  This License explicitly affirms your unlimited\r\npermission to run the unmodified Program.  The output from running a\r\ncovered work is covered by this License only if the output, given its\r\ncontent, constitutes a covered work.  This License acknowledges your\r\nrights of fair use or other equivalent, as provided by copyright law.\r\n\r\n  You may make, run and propagate covered works that you do not\r\nconvey, without conditions so long as your license otherwise remains\r\nin force.  You may convey covered works to others for the sole purpose\r\nof having them make modifications exclusively for you, or provide you\r\nwith facilities for running those works, provided that you comply with\r\nthe terms of this License in conveying all material for which you do\r\nnot control copyright.  Those thus making or running the covered works\r\nfor you must do so exclusively on your behalf, under your direction\r\nand control, on terms that prohibit them from making any copies of\r\nyour copyrighted material outside their relationship with you.\r\n\r\n  Conveying under any other circumstances is permitted solely under\r\nthe conditions stated below.  Sublicensing is not allowed; section 10\r\nmakes it unnecessary.\r\n\r\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\r\n\r\n  No covered work shall be deemed part of an effective technological\r\nmeasure under any applicable law fulfilling obligations under article\r\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\r\nsimilar laws prohibiting or restricting circumvention of such\r\nmeasures.\r\n\r\n  When you convey a covered work, you waive any legal power to forbid\r\ncircumvention of technological measures to the extent such circumvention\r\nis effected by exercising rights under this License with respect to\r\nthe covered work, and you disclaim any intention to limit operation or\r\nmodification of the work as a means of enforcing, against the work's\r\nusers, your or third parties' legal rights to forbid circumvention of\r\ntechnological measures.\r\n\r\n  4. Conveying Verbatim Copies.\r\n\r\n  You may convey verbatim copies of the Program's source code as you\r\nreceive it, in any medium, provided that you conspicuously and\r\nappropriately publish on each copy an appropriate copyright notice;\r\nkeep intact all notices stating that this License and any\r\nnon-permissive terms added in accord with section 7 apply to the code;\r\nkeep intact all notices of the absence of any warranty; and give all\r\nrecipients a copy of this License along with the Program.\r\n\r\n  You may charge any price or no price for each copy that you convey,\r\nand you may offer support or warranty protection for a fee.\r\n\r\n  5. Conveying Modified Source Versions.\r\n\r\n  You may convey a work based on the Program, or the modifications to\r\nproduce it from the Program, in the form of source code under the\r\nterms of section 4, provided that you also meet all of these conditions:\r\n\r\n    a) The work must carry prominent notices stating that you modified\r\n    it, and giving a relevant date.\r\n\r\n    b) The work must carry prominent notices stating that it is\r\n    released under this License and any conditions added under section\r\n    7.  This requirement modifies the requirement in section 4 to\r\n    \"keep intact all notices\".\r\n\r\n    c) You must license the entire work, as a whole, under this\r\n    License to anyone who comes into possession of a copy.  This\r\n    License will therefore apply, along with any applicable section 7\r\n    additional terms, to the whole of the work, and all its parts,\r\n    regardless of how they are packaged.  This License gives no\r\n    permission to license the work in any other way, but it does not\r\n    invalidate such permission if you have separately received it.\r\n\r\n    d) If the work has interactive user interfaces, each must display\r\n    Appropriate Legal Notices; however, if the Program has interactive\r\n    interfaces that do not display Appropriate Legal Notices, your\r\n    work need not make them do so.\r\n\r\n  A compilation of a covered work with other separate and independent\r\nworks, which are not by their nature extensions of the covered work,\r\nand which are not combined with it such as to form a larger program,\r\nin or on a volume of a storage or distribution medium, is called an\r\n\"aggregate\" if the compilation and its resulting copyright are not\r\nused to limit the access or legal rights of the compilation's users\r\nbeyond what the individual works permit.  Inclusion of a covered work\r\nin an aggregate does not cause this License to apply to the other\r\nparts of the aggregate.\r\n\r\n  6. Conveying Non-Source Forms.\r\n\r\n  You may convey a covered work in object code form under the terms\r\nof sections 4 and 5, provided that you also convey the\r\nmachine-readable Corresponding Source under the terms of this License,\r\nin one of these ways:\r\n\r\n    a) Convey the object code in, or embodied in, a physical product\r\n    (including a physical distribution medium), accompanied by the\r\n    Corresponding Source fixed on a durable physical medium\r\n    customarily used for software interchange.\r\n\r\n    b) Convey the object code in, or embodied in, a physical product\r\n    (including a physical distribution medium), accompanied by a\r\n    written offer, valid for at least three years and valid for as\r\n    long as you offer spare parts or customer support for that product\r\n    model, to give anyone who possesses the object code either (1) a\r\n    copy of the Corresponding Source for all the software in the\r\n    product that is covered by this License, on a durable physical\r\n    medium customarily used for software interchange, for a price no\r\n    more than your reasonable cost of physically performing this\r\n    conveying of source, or (2) access to copy the\r\n    Corresponding Source from a network server at no charge.\r\n\r\n    c) Convey individual copies of the object code with a copy of the\r\n    written offer to provide the Corresponding Source.  This\r\n    alternative is allowed only occasionally and noncommercially, and\r\n    only if you received the object code with such an offer, in accord\r\n    with subsection 6b.\r\n\r\n    d) Convey the object code by offering access from a designated\r\n    place (gratis or for a charge), and offer equivalent access to the\r\n    Corresponding Source in the same way through the same place at no\r\n    further charge.  You need not require recipients to copy the\r\n    Corresponding Source along with the object code.  If the place to\r\n    copy the object code is a network server, the Corresponding Source\r\n    may be on a different server (operated by you or a third party)\r\n    that supports equivalent copying facilities, provided you maintain\r\n    clear directions next to the object code saying where to find the\r\n    Corresponding Source.  Regardless of what server hosts the\r\n    Corresponding Source, you remain obligated to ensure that it is\r\n    available for as long as needed to satisfy these requirements.\r\n\r\n    e) Convey the object code using peer-to-peer transmission, provided\r\n    you inform other peers where the object code and Corresponding\r\n    Source of the work are being offered to the general public at no\r\n    charge under subsection 6d.\r\n\r\n  A separable portion of the object code, whose source code is excluded\r\nfrom the Corresponding Source as a System Library, need not be\r\nincluded in conveying the object code work.\r\n\r\n  A \"User Product\" is either (1) a \"consumer product\", which means any\r\ntangible personal property which is normally used for personal, family,\r\nor household purposes, or (2) anything designed or sold for incorporation\r\ninto a dwelling.  In determining whether a product is a consumer product,\r\ndoubtful cases shall be resolved in favor of coverage.  For a particular\r\nproduct received by a particular user, \"normally used\" refers to a\r\ntypical or common use of that class of product, regardless of the status\r\nof the particular user or of the way in which the particular user\r\nactually uses, or expects or is expected to use, the product.  A product\r\nis a consumer product regardless of whether the product has substantial\r\ncommercial, industrial or non-consumer uses, unless such uses represent\r\nthe only significant mode of use of the product.\r\n\r\n  \"Installation Information\" for a User Product means any methods,\r\nprocedures, authorization keys, or other information required to install\r\nand execute modified versions of a covered work in that User Product from\r\na modified version of its Corresponding Source.  The information must\r\nsuffice to ensure that the continued functioning of the modified object\r\ncode is in no case prevented or interfered with solely because\r\nmodification has been made.\r\n\r\n  If you convey an object code work under this section in, or with, or\r\nspecifically for use in, a User Product, and the conveying occurs as\r\npart of a transaction in which the right of possession and use of the\r\nUser Product is transferred to the recipient in perpetuity or for a\r\nfixed term (regardless of how the transaction is characterized), the\r\nCorresponding Source conveyed under this section must be accompanied\r\nby the Installation Information.  But this requirement does not apply\r\nif neither you nor any third party retains the ability to install\r\nmodified object code on the User Product (for example, the work has\r\nbeen installed in ROM).\r\n\r\n  The requirement to provide Installation Information does not include a\r\nrequirement to continue to provide support service, warranty, or updates\r\nfor a work that has been modified or installed by the recipient, or for\r\nthe User Product in which it has been modified or installed.  Access to a\r\nnetwork may be denied when the modification itself materially and\r\nadversely affects the operation of the network or violates the rules and\r\nprotocols for communication across the network.\r\n\r\n  Corresponding Source conveyed, and Installation Information provided,\r\nin accord with this section must be in a format that is publicly\r\ndocumented (and with an implementation available to the public in\r\nsource code form), and must require no special password or key for\r\nunpacking, reading or copying.\r\n\r\n  7. Additional Terms.\r\n\r\n  \"Additional permissions\" are terms that supplement the terms of this\r\nLicense by making exceptions from one or more of its conditions.\r\nAdditional permissions that are applicable to the entire Program shall\r\nbe treated as though they were included in this License, to the extent\r\nthat they are valid under applicable law.  If additional permissions\r\napply only to part of the Program, that part may be used separately\r\nunder those permissions, but the entire Program remains governed by\r\nthis License without regard to the additional permissions.\r\n\r\n  When you convey a copy of a covered work, you may at your option\r\nremove any additional permissions from that copy, or from any part of\r\nit.  (Additional permissions may be written to require their own\r\nremoval in certain cases when you modify the work.)  You may place\r\nadditional permissions on material, added by you to a covered work,\r\nfor which you have or can give appropriate copyright permission.\r\n\r\n  Notwithstanding any other provision of this License, for material you\r\nadd to a covered work, you may (if authorized by the copyright holders of\r\nthat material) supplement the terms of this License with terms:\r\n\r\n    a) Disclaiming warranty or limiting liability differently from the\r\n    terms of sections 15 and 16 of this License; or\r\n\r\n    b) Requiring preservation of specified reasonable legal notices or\r\n    author attributions in that material or in the Appropriate Legal\r\n    Notices displayed by works containing it; or\r\n\r\n    c) Prohibiting misrepresentation of the origin of that material, or\r\n    requiring that modified versions of such material be marked in\r\n    reasonable ways as different from the original version; or\r\n\r\n    d) Limiting the use for publicity purposes of names of licensors or\r\n    authors of the material; or\r\n\r\n    e) Declining to grant rights under trademark law for use of some\r\n    trade names, trademarks, or service marks; or\r\n\r\n    f) Requiring indemnification of licensors and authors of that\r\n    material by anyone who conveys the material (or modified versions of\r\n    it) with contractual assumptions of liability to the recipient, for\r\n    any liability that these contractual assumptions directly impose on\r\n    those licensors and authors.\r\n\r\n  All other non-permissive additional terms are considered \"further\r\nrestrictions\" within the meaning of section 10.  If the Program as you\r\nreceived it, or any part of it, contains a notice stating that it is\r\ngoverned by this License along with a term that is a further\r\nrestriction, you may remove that term.  If a license document contains\r\na further restriction but permits relicensing or conveying under this\r\nLicense, you may add to a covered work material governed by the terms\r\nof that license document, provided that the further restriction does\r\nnot survive such relicensing or conveying.\r\n\r\n  If you add terms to a covered work in accord with this section, you\r\nmust place, in the relevant source files, a statement of the\r\nadditional terms that apply to those files, or a notice indicating\r\nwhere to find the applicable terms.\r\n\r\n  Additional terms, permissive or non-permissive, may be stated in the\r\nform of a separately written license, or stated as exceptions;\r\nthe above requirements apply either way.\r\n\r\n  8. Termination.\r\n\r\n  You may not propagate or modify a covered work except as expressly\r\nprovided under this License.  Any attempt otherwise to propagate or\r\nmodify it is void, and will automatically terminate your rights under\r\nthis License (including any patent licenses granted under the third\r\nparagraph of section 11).\r\n\r\n  However, if you cease all violation of this License, then your\r\nlicense from a particular copyright holder is reinstated (a)\r\nprovisionally, unless and until the copyright holder explicitly and\r\nfinally terminates your license, and (b) permanently, if the copyright\r\nholder fails to notify you of the violation by some reasonable means\r\nprior to 60 days after the cessation.\r\n\r\n  Moreover, your license from a particular copyright holder is\r\nreinstated permanently if the copyright holder notifies you of the\r\nviolation by some reasonable means, this is the first time you have\r\nreceived notice of violation of this License (for any work) from that\r\ncopyright holder, and you cure the violation prior to 30 days after\r\nyour receipt of the notice.\r\n\r\n  Termination of your rights under this section does not terminate the\r\nlicenses of parties who have received copies or rights from you under\r\nthis License.  If your rights have been terminated and not permanently\r\nreinstated, you do not qualify to receive new licenses for the same\r\nmaterial under section 10.\r\n\r\n  9. Acceptance Not Required for Having Copies.\r\n\r\n  You are not required to accept this License in order to receive or\r\nrun a copy of the Program.  Ancillary propagation of a covered work\r\noccurring solely as a consequence of using peer-to-peer transmission\r\nto receive a copy likewise does not require acceptance.  However,\r\nnothing other than this License grants you permission to propagate or\r\nmodify any covered work.  These actions infringe copyright if you do\r\nnot accept this License.  Therefore, by modifying or propagating a\r\ncovered work, you indicate your acceptance of this License to do so.\r\n\r\n  10. Automatic Licensing of Downstream Recipients.\r\n\r\n  Each time you convey a covered work, the recipient automatically\r\nreceives a license from the original licensors, to run, modify and\r\npropagate that work, subject to this License.  You are not responsible\r\nfor enforcing compliance by third parties with this License.\r\n\r\n  An \"entity transaction\" is a transaction transferring control of an\r\norganization, or substantially all assets of one, or subdividing an\r\norganization, or merging organizations.  If propagation of a covered\r\nwork results from an entity transaction, each party to that\r\ntransaction who receives a copy of the work also receives whatever\r\nlicenses to the work the party's predecessor in interest had or could\r\ngive under the previous paragraph, plus a right to possession of the\r\nCorresponding Source of the work from the predecessor in interest, if\r\nthe predecessor has it or can get it with reasonable efforts.\r\n\r\n  You may not impose any further restrictions on the exercise of the\r\nrights granted or affirmed under this License.  For example, you may\r\nnot impose a license fee, royalty, or other charge for exercise of\r\nrights granted under this License, and you may not initiate litigation\r\n(including a cross-claim or counterclaim in a lawsuit) alleging that\r\nany patent claim is infringed by making, using, selling, offering for\r\nsale, or importing the Program or any portion of it.\r\n\r\n  11. Patents.\r\n\r\n  A \"contributor\" is a copyright holder who authorizes use under this\r\nLicense of the Program or a work on which the Program is based.  The\r\nwork thus licensed is called the contributor's \"contributor version\".\r\n\r\n  A contributor's \"essential patent claims\" are all patent claims\r\nowned or controlled by the contributor, whether already acquired or\r\nhereafter acquired, that would be infringed by some manner, permitted\r\nby this License, of making, using, or selling its contributor version,\r\nbut do not include claims that would be infringed only as a\r\nconsequence of further modification of the contributor version.  For\r\npurposes of this definition, \"control\" includes the right to grant\r\npatent sublicenses in a manner consistent with the requirements of\r\nthis License.\r\n\r\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\r\npatent license under the contributor's essential patent claims, to\r\nmake, use, sell, offer for sale, import and otherwise run, modify and\r\npropagate the contents of its contributor version.\r\n\r\n  In the following three paragraphs, a \"patent license\" is any express\r\nagreement or commitment, however denominated, not to enforce a patent\r\n(such as an express permission to practice a patent or covenant not to\r\nsue for patent infringement).  To \"grant\" such a patent license to a\r\nparty means to make such an agreement or commitment not to enforce a\r\npatent against the party.\r\n\r\n  If you convey a covered work, knowingly relying on a patent license,\r\nand the Corresponding Source of the work is not available for anyone\r\nto copy, free of charge and under the terms of this License, through a\r\npublicly available network server or other readily accessible means,\r\nthen you must either (1) cause the Corresponding Source to be so\r\navailable, or (2) arrange to deprive yourself of the benefit of the\r\npatent license for this particular work, or (3) arrange, in a manner\r\nconsistent with the requirements of this License, to extend the patent\r\nlicense to downstream recipients.  \"Knowingly relying\" means you have\r\nactual knowledge that, but for the patent license, your conveying the\r\ncovered work in a country, or your recipient's use of the covered work\r\nin a country, would infringe one or more identifiable patents in that\r\ncountry that you have reason to believe are valid.\r\n\r\n  If, pursuant to or in connection with a single transaction or\r\narrangement, you convey, or propagate by procuring conveyance of, a\r\ncovered work, and grant a patent license to some of the parties\r\nreceiving the covered work authorizing them to use, propagate, modify\r\nor convey a specific copy of the covered work, then the patent license\r\nyou grant is automatically extended to all recipients of the covered\r\nwork and works based on it.\r\n\r\n  A patent license is \"discriminatory\" if it does not include within\r\nthe scope of its coverage, prohibits the exercise of, or is\r\nconditioned on the non-exercise of one or more of the rights that are\r\nspecifically granted under this License.  You may not convey a covered\r\nwork if you are a party to an arrangement with a third party that is\r\nin the business of distributing software, under which you make payment\r\nto the third party based on the extent of your activity of conveying\r\nthe work, and under which the third party grants, to any of the\r\nparties who would receive the covered work from you, a discriminatory\r\npatent license (a) in connection with copies of the covered work\r\nconveyed by you (or copies made from those copies), or (b) primarily\r\nfor and in connection with specific products or compilations that\r\ncontain the covered work, unless you entered into that arrangement,\r\nor that patent license was granted, prior to 28 March 2007.\r\n\r\n  Nothing in this License shall be construed as excluding or limiting\r\nany implied license or other defenses to infringement that may\r\notherwise be available to you under applicable patent law.\r\n\r\n  12. No Surrender of Others' Freedom.\r\n\r\n  If conditions are imposed on you (whether by court order, agreement or\r\notherwise) that contradict the conditions of this License, they do not\r\nexcuse you from the conditions of this License.  If you cannot convey a\r\ncovered work so as to satisfy simultaneously your obligations under this\r\nLicense and any other pertinent obligations, then as a consequence you may\r\nnot convey it at all.  For example, if you agree to terms that obligate you\r\nto collect a royalty for further conveying from those to whom you convey\r\nthe Program, the only way you could satisfy both those terms and this\r\nLicense would be to refrain entirely from conveying the Program.\r\n\r\n  13. Use with the GNU Affero General Public License.\r\n\r\n  Notwithstanding any other provision of this License, you have\r\npermission to link or combine any covered work with a work licensed\r\nunder version 3 of the GNU Affero General Public License into a single\r\ncombined work, and to convey the resulting work.  The terms of this\r\nLicense will continue to apply to the part which is the covered work,\r\nbut the special requirements of the GNU Affero General Public License,\r\nsection 13, concerning interaction through a network will apply to the\r\ncombination as such.\r\n\r\n  14. Revised Versions of this License.\r\n\r\n  The Free Software Foundation may publish revised and/or new versions of\r\nthe GNU General Public License from time to time.  Such new versions will\r\nbe similar in spirit to the present version, but may differ in detail to\r\naddress new problems or concerns.\r\n\r\n  Each version is given a distinguishing version number.  If the\r\nProgram specifies that a certain numbered version of the GNU General\r\nPublic License \"or any later version\" applies to it, you have the\r\noption of following the terms and conditions either of that numbered\r\nversion or of any later version published by the Free Software\r\nFoundation.  If the Program does not specify a version number of the\r\nGNU General Public License, you may choose any version ever published\r\nby the Free Software Foundation.\r\n\r\n  If the Program specifies that a proxy can decide which future\r\nversions of the GNU General Public License can be used, that proxy's\r\npublic statement of acceptance of a version permanently authorizes you\r\nto choose that version for the Program.\r\n\r\n  Later license versions may give you additional or different\r\npermissions.  However, no additional obligations are imposed on any\r\nauthor or copyright holder as a result of your choosing to follow a\r\nlater version.\r\n\r\n  15. Disclaimer of Warranty.\r\n\r\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\r\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\r\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\r\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\r\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\r\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\r\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\r\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\r\n\r\n  16. Limitation of Liability.\r\n\r\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\r\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\r\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\r\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\r\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\r\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\r\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\r\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\r\nSUCH DAMAGES.\r\n\r\n  17. Interpretation of Sections 15 and 16.\r\n\r\n  If the disclaimer of warranty and limitation of liability provided\r\nabove cannot be given local legal effect according to their terms,\r\nreviewing courts shall apply local law that most closely approximates\r\nan absolute waiver of all civil liability in connection with the\r\nProgram, unless a warranty or assumption of liability accompanies a\r\ncopy of the Program in return for a fee.\r\n\r\n                     END OF TERMS AND CONDITIONS\r\n\r\n            How to Apply These Terms to Your New Programs\r\n\r\n  If you develop a new program, and you want it to be of the greatest\r\npossible use to the public, the best way to achieve this is to make it\r\nfree software which everyone can redistribute and change under these terms.\r\n\r\n  To do so, attach the following notices to the program.  It is safest\r\nto attach them to the start of each source file to most effectively\r\nstate the exclusion of warranty; and each file should have at least\r\nthe \"copyright\" line and a pointer to where the full notice is found.\r\n\r\n    <one line to give the program's name and a brief idea of what it does.>\r\n    Copyright (C) <year>  <name of author>\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\nAlso add information on how to contact you by electronic and paper mail.\r\n\r\n  If the program does terminal interaction, make it output a short\r\nnotice like this when it starts in an interactive mode:\r\n\r\n    <program>  Copyright (C) <year>  <name of author>\r\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\r\n    This is free software, and you are welcome to redistribute it\r\n    under certain conditions; type `show c' for details.\r\n\r\nThe hypothetical commands `show w' and `show c' should show the appropriate\r\nparts of the General Public License.  Of course, your program's commands\r\nmight be different; for a GUI interface, you would use an \"about box\".\r\n\r\n  You should also get your employer (if you work as a programmer) or school,\r\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\r\nFor more information on this, and how to apply and follow the GNU GPL, see\r\n<http://www.gnu.org/licenses/>.\r\n\r\n  The GNU General Public License does not permit incorporating your program\r\ninto proprietary programs.  If your program is a subroutine library, you\r\nmay consider it more useful to permit linking proprietary applications with\r\nthe library.  If this is what you want to do, use the GNU Lesser General\r\nPublic License instead of this License.  But first, please read\r\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\r\n\r\n*/",
		"ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dst\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dst\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"}]",
		"ContractName": "WETH9",
		"Address": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
		"CompilerVersion": "v0.4.19+commit.c4cbbb05",
		"OptimizationUsed": "0",
		"Runs": "200",
		"ConstructorArguments": "",
		"Library": "",
		"SwarmSource": "bzzr://deb4c2ccab3c2fdca32ab3f46728389c2fe2c165d5fafa07661e4e004f6c344a"
	},
	{
		"SourceCode": "pragma solidity ^0.4.9;\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) throw;\r\n  }\r\n}\r\n\r\ncontract Token {\r\n  /// @return total amount of tokens\r\n  function totalSupply() constant returns (uint256 supply) {}\r\n\r\n  /// @param _owner The address from which the balance will be retrieved\r\n  /// @return The balance\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `msg.sender`\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n  /// @param _from The address of the sender\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @param _value The amount of wei to be approved for transfer\r\n  /// @return Whether the approval was successful or not\r\n  function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n  /// @param _owner The address of the account owning tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @return Amount of remaining tokens allowed to spent\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n  uint public decimals;\r\n  string public name;\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n  function transfer(address _to, uint256 _value) returns (bool success) {\r\n    //Default assumes totalSupply can't be over max (2^256 - 1).\r\n    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n    //Replace the if with this one instead.\r\n    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n    //if (balances[msg.sender] >= _value && _value > 0) {\r\n      balances[msg.sender] -= _value;\r\n      balances[_to] += _value;\r\n      Transfer(msg.sender, _to, _value);\r\n      return true;\r\n    } else { return false; }\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n    //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n      balances[_to] += _value;\r\n      balances[_from] -= _value;\r\n      allowed[_from][msg.sender] -= _value;\r\n      Transfer(_from, _to, _value);\r\n      return true;\r\n    } else { return false; }\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n  uint256 public totalSupply;\r\n}\r\n\r\ncontract ReserveToken is StandardToken, SafeMath {\r\n  address public minter;\r\n  function ReserveToken() {\r\n    minter = msg.sender;\r\n  }\r\n  function create(address account, uint amount) {\r\n    if (msg.sender != minter) throw;\r\n    balances[account] = safeAdd(balances[account], amount);\r\n    totalSupply = safeAdd(totalSupply, amount);\r\n  }\r\n  function destroy(address account, uint amount) {\r\n    if (msg.sender != minter) throw;\r\n    if (balances[account] < amount) throw;\r\n    balances[account] = safeSub(balances[account], amount);\r\n    totalSupply = safeSub(totalSupply, amount);\r\n  }\r\n}\r\n\r\ncontract AccountLevels {\r\n  //given a user, returns an account level\r\n  //0 = regular user (pays take fee and make fee)\r\n  //1 = market maker silver (pays take fee, no make fee, gets rebate)\r\n  //2 = market maker gold (pays take fee, no make fee, gets entire counterparty's take fee as rebate)\r\n  function accountLevel(address user) constant returns(uint) {}\r\n}\r\n\r\ncontract AccountLevelsTest is AccountLevels {\r\n  mapping (address => uint) public accountLevels;\r\n\r\n  function setAccountLevel(address user, uint level) {\r\n    accountLevels[user] = level;\r\n  }\r\n\r\n  function accountLevel(address user) constant returns(uint) {\r\n    return accountLevels[user];\r\n  }\r\n}\r\n\r\ncontract EtherDelta is SafeMath {\r\n  address public admin; //the admin address\r\n  address public feeAccount; //the account that will receive fees\r\n  address public accountLevelsAddr; //the address of the AccountLevels contract\r\n  uint public feeMake; //percentage times (1 ether)\r\n  uint public feeTake; //percentage times (1 ether)\r\n  uint public feeRebate; //percentage times (1 ether)\r\n  mapping (address => mapping (address => uint)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\r\n  mapping (address => mapping (bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\r\n  mapping (address => mapping (bytes32 => uint)) public orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\r\n\r\n  event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user);\r\n  event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\r\n  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\r\n  event Deposit(address token, address user, uint amount, uint balance);\r\n  event Withdraw(address token, address user, uint amount, uint balance);\r\n\r\n  function EtherDelta(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) {\r\n    admin = admin_;\r\n    feeAccount = feeAccount_;\r\n    accountLevelsAddr = accountLevelsAddr_;\r\n    feeMake = feeMake_;\r\n    feeTake = feeTake_;\r\n    feeRebate = feeRebate_;\r\n  }\r\n\r\n  function() {\r\n    throw;\r\n  }\r\n\r\n  function changeAdmin(address admin_) {\r\n    if (msg.sender != admin) throw;\r\n    admin = admin_;\r\n  }\r\n\r\n  function changeAccountLevelsAddr(address accountLevelsAddr_) {\r\n    if (msg.sender != admin) throw;\r\n    accountLevelsAddr = accountLevelsAddr_;\r\n  }\r\n\r\n  function changeFeeAccount(address feeAccount_) {\r\n    if (msg.sender != admin) throw;\r\n    feeAccount = feeAccount_;\r\n  }\r\n\r\n  function changeFeeMake(uint feeMake_) {\r\n    if (msg.sender != admin) throw;\r\n    if (feeMake_ > feeMake) throw;\r\n    feeMake = feeMake_;\r\n  }\r\n\r\n  function changeFeeTake(uint feeTake_) {\r\n    if (msg.sender != admin) throw;\r\n    if (feeTake_ > feeTake || feeTake_ < feeRebate) throw;\r\n    feeTake = feeTake_;\r\n  }\r\n\r\n  function changeFeeRebate(uint feeRebate_) {\r\n    if (msg.sender != admin) throw;\r\n    if (feeRebate_ < feeRebate || feeRebate_ > feeTake) throw;\r\n    feeRebate = feeRebate_;\r\n  }\r\n\r\n  function deposit() payable {\r\n    tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);\r\n    Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\r\n  }\r\n\r\n  function withdraw(uint amount) {\r\n    if (tokens[0][msg.sender] < amount) throw;\r\n    tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);\r\n    if (!msg.sender.call.value(amount)()) throw;\r\n    Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\r\n  }\r\n\r\n  function depositToken(address token, uint amount) {\r\n    //remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\r\n    if (token==0) throw;\r\n    if (!Token(token).transferFrom(msg.sender, this, amount)) throw;\r\n    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\r\n    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n  function withdrawToken(address token, uint amount) {\r\n    if (token==0) throw;\r\n    if (tokens[token][msg.sender] < amount) throw;\r\n    tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\r\n    if (!Token(token).transfer(msg.sender, amount)) throw;\r\n    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n  function balanceOf(address token, address user) constant returns (uint) {\r\n    return tokens[token][user];\r\n  }\r\n\r\n  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    orders[msg.sender][hash] = true;\r\n    Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);\r\n  }\r\n\r\n  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) {\r\n    //amount is in amountGet terms\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    if (!(\r\n      (orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\r\n      block.number <= expires &&\r\n      safeAdd(orderFills[user][hash], amount) <= amountGet\r\n    )) throw;\r\n    tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\r\n    orderFills[user][hash] = safeAdd(orderFills[user][hash], amount);\r\n    Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\r\n  }\r\n\r\n  function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\r\n    uint feeMakeXfer = safeMul(amount, feeMake) / (1 ether);\r\n    uint feeTakeXfer = safeMul(amount, feeTake) / (1 ether);\r\n    uint feeRebateXfer = 0;\r\n    if (accountLevelsAddr != 0x0) {\r\n      uint accountLevel = AccountLevels(accountLevelsAddr).accountLevel(user);\r\n      if (accountLevel==1) feeRebateXfer = safeMul(amount, feeRebate) / (1 ether);\r\n      if (accountLevel==2) feeRebateXfer = feeTakeXfer;\r\n    }\r\n    tokens[tokenGet][msg.sender] = safeSub(tokens[tokenGet][msg.sender], safeAdd(amount, feeTakeXfer));\r\n    tokens[tokenGet][user] = safeAdd(tokens[tokenGet][user], safeSub(safeAdd(amount, feeRebateXfer), feeMakeXfer));\r\n    tokens[tokenGet][feeAccount] = safeAdd(tokens[tokenGet][feeAccount], safeSub(safeAdd(feeMakeXfer, feeTakeXfer), feeRebateXfer));\r\n    tokens[tokenGive][user] = safeSub(tokens[tokenGive][user], safeMul(amountGive, amount) / amountGet);\r\n    tokens[tokenGive][msg.sender] = safeAdd(tokens[tokenGive][msg.sender], safeMul(amountGive, amount) / amountGet);\r\n  }\r\n\r\n  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool) {\r\n    if (!(\r\n      tokens[tokenGet][sender] >= amount &&\r\n      availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\r\n    )) return false;\r\n    return true;\r\n  }\r\n\r\n  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    if (!(\r\n      (orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\r\n      block.number <= expires\r\n    )) return 0;\r\n    uint available1 = safeSub(amountGet, orderFills[user][hash]);\r\n    uint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;\r\n    if (available1<available2) return available1;\r\n    return available2;\r\n  }\r\n\r\n  function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    return orderFills[user][hash];\r\n  }\r\n\r\n  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    if (!(orders[msg.sender][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == msg.sender)) throw;\r\n    orderFills[msg.sender][hash] = amountGet;\r\n    Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\r\n  }\r\n}",
		"ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"trade\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"order\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderFills\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"amountFilled\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeMake_\",\"type\":\"uint256\"}],\"name\":\"changeFeeMake\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeMake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeRebate_\",\"type\":\"uint256\"}],\"name\":\"changeFeeRebate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"testTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeAccount_\",\"type\":\"address\"}],\"name\":\"changeFeeAccount\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeRebate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeTake_\",\"type\":\"uint256\"}],\"name\":\"changeFeeTake\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin_\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orders\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeTake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"accountLevelsAddr_\",\"type\":\"address\"}],\"name\":\"changeAccountLevelsAddr\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accountLevelsAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"availableVolume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"admin_\",\"type\":\"address\"},{\"name\":\"feeAccount_\",\"type\":\"address\"},{\"name\":\"accountLevelsAddr_\",\"type\":\"address\"},{\"name\":\"feeMake_\",\"type\":\"uint256\"},{\"name\":\"feeTake_\",\"type\":\"uint256\"},{\"name\":\"feeRebate_\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenGive\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expires\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Order\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenGive\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expires\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"v\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"r\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenGive\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"get\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"give\",\"type\":\"address\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]",
		"ContractName": "EtherDelta",
		"Address": "0x8d12a197cb00d4747a1fe03395095ce2a5cc6819",
		"CompilerVersion": "v0.4.9+commit.364da425",
		"OptimizationUsed": "1",
		"Runs": "200",
		"ConstructorArguments": "0000000000000000000000001ed014aec47fae44c9e55bac7662c0b78ae617980000000000000000000000001ed014aec47fae44c9e55bac7662c0b78ae6179800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aa87bee5380000000000000000000000000000000000000000000000000000000000000000000",
		"Library": "",
		"SwarmSource": "bzzr://468be9e52c7f41ff50afc583b7c02aff6937a69ed155212dd15604aa874fef0a"
	},
	{
		"SourceCode": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
		"ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetSpentToday\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_daylimit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SingleTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MultiTransact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfirmationNeeded\",\"type\":\"event\"}]",
		"ContractName": "Wallet",
		"Address": "0x94a9251580f1bd08e641f735feebf066addee64c",
		"CompilerVersion": "v0.3.2+commit.81ae2a7",
		"OptimizationUsed": "0",
		"Runs": "200",
		"ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000074f801f33951767bc9826f12624bf0892ae09733",
		"Library": "",
		"SwarmSource": ""
	}
]
